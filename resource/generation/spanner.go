package generation

import (
	"bytes"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/go-playground/errors/v5"
)

func (c *GenerationClient) RunSpannerGeneration() error {
	if err := c.removeDestinationFiles(); err != nil {
		return errors.Wrap(err, "c.removeDestinationFiles()")
	}

	types, err := c.buildPatcherTypesFromSource()
	if err != nil {
		return errors.Wrap(err, "c.buildPatcherTypesFromSource()")
	}

	if err := c.generateResourceInterfaces(types); err != nil {
		return errors.Wrap(err, "c.generateResourceInterfaces()")
	}

	for _, t := range types {
		if err := c.generatePatcherTypes(t); err != nil {
			return errors.Wrap(err, "c.generatePatcherTypes()")
		}
	}

	if err := c.generateResourceTests(types); err != nil {
		return errors.Wrap(err, "c.generateResourceTests()")
	}

	return nil
}

func (c *GenerationClient) generateResourceInterfaces(types []*generatedType) error {
	output, err := c.generateTemplateOutput(resourcesInterfaceTemplate, map[string]any{"Source": c.resourceSource, "Types": types})
	if err != nil {
		return errors.Wrap(err, "generateTemplateOutput()")
	}

	destinationFile := filepath.Join(c.spannerDestination, resourceInterfaceOutputFilename)

	file, err := os.Create(destinationFile)
	if err != nil {
		return errors.Wrap(err, "os.Create()")
	}
	defer file.Close()

	if err := c.writeBytesToFile(destinationFile, file, output); err != nil {
		return errors.Wrap(err, "c.writeBytesToFile()")
	}

	return nil
}

func (c *GenerationClient) generateResourceTests(types []*generatedType) error {
	output, err := c.generateTemplateOutput(resourcesTestTemplate, map[string]any{"Source": c.resourceSource, "Types": types})
	if err != nil {
		return errors.Wrap(err, "generateTemplateOutput()")
	}

	destinationFile := filepath.Join(c.spannerDestination, resourcesTestFileName)

	file, err := os.Create(destinationFile)
	if err != nil {
		return errors.Wrap(err, "os.Create()")
	}
	defer file.Close()

	if err := c.writeBytesToFile(destinationFile, file, output); err != nil {
		return errors.Wrap(err, "c.writeBytesToFile()")
	}

	return nil
}

func (c *GenerationClient) generatePatcherTypes(generatedType *generatedType) error {
	fileName := strings.ToLower(c.caser.ToSnake(c.pluralize(generatedType.Name)))
	destinationFilePath := c.outputDestination(c.spannerDestination, fileName)

	log.Printf("Generating spanner file: %v\n", destinationFilePath)

	output, err := c.generateTemplateOutput(resourceFileTemplate, map[string]any{
		"Source":          c.resourceSource,
		"Name":            generatedType.Name,
		"IsView":          generatedType.IsView,
		"Fields":          generatedType.Fields,
		"IsCompoundTable": generatedType.IsCompoundTable,
	})
	if err != nil {
		return errors.Wrap(err, "generateTemplateOutput()")
	}

	file, err := os.Create(destinationFilePath)
	if err != nil {
		return errors.Wrap(err, "os.Create()")
	}
	defer file.Close()

	if err := c.writeBytesToFile(destinationFilePath, file, output); err != nil {
		return errors.Wrap(err, "c.writeBytesToFile()")
	}

	return nil
}

func (c *GenerationClient) removeDestinationFiles() error {
	dir, err := os.Open(c.spannerDestination)
	if err != nil {
		return errors.Wrap(err, "os.Open()")
	}
	defer dir.Close()

	files, err := dir.Readdirnames(0)
	if err != nil {
		return errors.Wrap(err, "dir.Readdirnames()")
	}

	for _, f := range files {
		if f == c.resourceSource {
			continue
		}

		content, err := os.ReadFile(filepath.Join(c.spannerDestination, f))
		if err != nil {
			return errors.Wrap(err, "os.ReadFile()")
		}

		generationHeader := "// Code generated by spannergen. DO NOT EDIT."
		if bytes.HasPrefix(content, []byte(generationHeader)) {
			if err := os.Remove(filepath.Join(c.spannerDestination, f)); err != nil {
				return errors.Wrap(err, "os.Remove()")
			}
		}
	}

	return nil
}

func (c *GenerationClient) buildPatcherTypesFromSource() ([]*generatedType, error) {
	tk := token.NewFileSet()
	parse, err := parser.ParseFile(tk, c.resourceSource, nil, 0)
	if err != nil {
		return nil, errors.Wrap(err, "parser.ParseFile()")
	}

	if parse == nil || parse.Scope == nil {
		return nil, errors.New("unable to parse file")
	}

	typeList := make([]*generatedType, 0)

	for k, v := range parse.Scope.Objects {
		var fields []*typeField

		spec, ok := v.Decl.(*ast.TypeSpec)
		if !ok {
			continue
		}
		structType, ok := spec.Type.(*ast.StructType)
		if !ok {
			continue
		}
		if structType.Fields == nil {
			continue
		}

		isCompoundTable := true
		tableName := c.pluralize(k)

		table, ok := c.tableFieldLookup[tableName]
		if !ok || table == nil {
			return nil, errors.Newf("table not found: %s", tableName)
		}

		for _, f := range structType.Fields.List {
			if len(f.Names) == 0 {
				continue
			}

			fields = append(fields, c.typeFieldFromAstField(table, f, &isCompoundTable))
		}

		typeList = append(typeList, &generatedType{
			Name:            k,
			Fields:          fields,
			IsCompoundTable: isCompoundTable,
		})
	}

	sort.Slice(typeList, func(i, j int) bool {
		return typeList[i].Name < typeList[j].Name
	})

	return typeList, nil
}

func (c *GenerationClient) typeFieldFromAstField(tableMetadata *TableMetadata, f *ast.Field, isCompoundTable *bool) *typeField {
	field := &typeField{
		Name: f.Names[0].Name,
	}

	field.Type = fieldType(f.Type, false)

	if f.Tag != nil {
		field.Tag = f.Tag.Value
	}

	if field.Tag == "" {
		return field
	}

	structTag := reflect.StructTag(field.Tag[1 : len(field.Tag)-1])
	column := structTag.Get("spanner")

	if data, ok := tableMetadata.Columns[column]; ok {
		field.IsPrimaryKey = data.ConstraintType == PrimaryKey
		field.IsIndex = data.IsIndex

		if data.ConstraintType != PrimaryKey && data.ConstraintType != ForeignKey {
			*isCompoundTable = false
		}
	}

	return field
}

func (c *GenerationClient) generateTemplateOutput(fileTemplate string, data map[string]any) ([]byte, error) {
	tmpl, err := template.New(fileTemplate).Funcs(c.templateFuncs()).Parse(fileTemplate)
	if err != nil {
		return nil, errors.Wrap(err, "template.Parse()")
	}

	buf := bytes.NewBuffer([]byte{})
	if err := tmpl.Execute(buf, data); err != nil {
		return nil, errors.Wrap(err, "tmpl.Execute()")
	}

	return buf.Bytes(), nil
}
