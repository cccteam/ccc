package generation

import "fmt"

var (
	resourcesInterfaceTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"github.com/cccteam/ccc/resource"
)

type Resourcer interface {
	resource.Resourcer
{{ FormatResourceInterfaceTypes .Types .ComputedResourceTypes }}
}`

	resourceFileTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"context"
	"reflect"
	"time"

	"cloud.google.com/go/civil"
	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource"
	"github.com/cccteam/ccc/queryset"
	"github.com/cccteam/patcher"
	"github.com/go-playground/errors/v5"
	"github.com/shopspring/decimal"
)

func ({{ .Resource.Name }}) Resource() accesstypes.Resource {
	return "{{ Pluralize .Resource.Name }}"
}

func ({{ .Resource.Name }}) DefaultConfig() resource.Config {
	{{- if not .Resource.IsVirtual }}
	return defaultConfig()
	{{- else }}
	return resource.Config{}
	{{- end }}
}

type {{ .Resource.Name }}Query struct {
	qSet *resource.QuerySet[{{ .Resource.Name }}]
}

func New{{ .Resource.Name }}Query() *{{ .Resource.Name }}Query {
	return &{{ .Resource.Name }}Query{qSet: resource.NewQuerySet(resource.NewMetadata[{{ .Resource.Name }}]())}
}

func New{{ .Resource.Name }}QueryFromQuerySet(qSet *resource.QuerySet[{{ .Resource.Name }}]) *{{ .Resource.Name }}Query {
	return &{{ .Resource.Name }}Query{qSet: qSet}
}

{{ range $field := .Resource.Fields }}
{{ if $field.IsUniqueIndex }}
func (q *{{ $field.Parent.Name }}Query) Set{{ $field.Name }}(v {{ $field.ResolvedType }}) *{{ $field.Parent.Name }}Query {
	q.qSet.SetKey("{{ $field.Name }}", v)

	return q
}

func (q *{{ $field.Parent.Name }}Query) {{ $field.Name }}() {{ $field.ResolvedType }} {
	v, _ := q.qSet.Key("{{ $field.Name }}").({{ $field.ResolvedType }})

	return v
}
{{ end }}
{{ end }}

func (q *{{ .Resource.Name }}Query) Read(ctx context.Context, txn resource.ReadOnlyTransaction) (*{{ .Resource.Name }}, error) {
	return q.qSet.Read(ctx, txn)
}

func (q *{{ .Resource.Name }}Query) List(ctx context.Context, txn resource.ReadOnlyTransaction) iter.Seq2[*{{ .Resource.Name }}, error] {
	return q.qSet.List(ctx, txn)
}

func (q *{{ .Resource.Name }}Query) BatchList(ctx context.Context, client resource.Client, size int) iter.Seq[iter.Seq2[*{{ .Resource.Name }}, error]] {
	return q.qSet.BatchList(ctx, client, size)
}

func (q *{{ .Resource.Name }}Query) AddColumns(c *{{ .Resource.Name }}Columns) *{{ .Resource.Name }}Query {
	for _, field := range c.fields {
		q.qSet.AddField(field)
	}

	return q
}

{{ if .Resource.IsQueryClauseEligible -}}
func (q *{{ .Resource.Name }}Query) Where(c {{ .Resource.Name }}QueryClause) *{{ .Resource.Name }}Query {
	if err := c.clause.Validate(); err != nil {
		panic(err)
	}
	q.qSet.SetWhereClause(c.clause)

	return q
}

func (q *{{ .Resource.Name }}Query) Sort(sort *{{ .Resource.Name }}Sort) *{{ .Resource.Name }}Query {
	q.qSet.SetSortFields(sort.sortFields)

	return q
}

func (q *{{ .Resource.Name }}Query) Limit(n uint64) *{{ .Resource.Name }}Query {
	q.qSet.SetLimit(&n)

	return q
}

func (q *{{ .Resource.Name }}Query) Offset(n uint64) *{{ .Resource.Name }}Query {
	q.qSet.SetOffset(&n)

	return q
}
{{- end }}

type {{ .Resource.Name }}Columns struct {
	fields []accesstypes.Field
}

func New{{ .Resource.Name }}Columns() *{{ .Resource.Name }}Columns {
	return &{{ .Resource.Name }}Columns{}
}

func (c *{{ .Resource.Name }}Columns) All() *{{ .Resource.Name }}Columns {
	c.fields = []accesstypes.Field{
	{{- range $field := .Resource.Fields }}
		"{{ $field.Name }}",
	{{- end }}
	}

	return c
}

{{ range $field := .Resource.Fields }}
func (c *{{ $field.Parent.Name }}Columns) {{ $field.Name }}() *{{ $field.Parent.Name }}Columns {
	c.fields = append(c.fields, "{{ $field.Name }}")

	return c
}
{{ end }}

{{ if .Resource.IsQueryClauseEligible -}}
type {{ .Resource.Name }}QueryPartialClause struct {
	partialClause resource.PartialQueryClause
}

func New{{ .Resource.Name }}QueryClause() {{ .Resource.Name }}QueryPartialClause {
	return {{ .Resource.Name }}QueryPartialClause{partialClause: resource.NewPartialQueryClause()}
}

func (p {{ .Resource.Name }}QueryPartialClause) Group(qc {{ .Resource.Name }}QueryClause) {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: p.partialClause.Group(qc.clause)}
}

{{ range $field := .Resource.Fields }}
{{ if $field.IsQueryClauseEligible -}}
{{ if $unwrappedType := $field.UnwrappedNullType -}}
func (p {{ $field.Parent.Name }}QueryPartialClause) {{ $field.Name }}() {{ $field.Parent.Name }}QueryIdent[{{ $unwrappedType }}] {
	return {{ $field.Parent.Name }}QueryIdent[{{ $unwrappedType }}]{Ident: resource.NewIdent[{{ $unwrappedType }}]("{{ $field.Name }}", p.partialClause, {{ $field.IsIndex }})}
}
{{- else }}
func (p {{ $field.Parent.Name }}QueryPartialClause) {{ $field.Name }}() {{ $field.Parent.Name }}QueryIdent[{{ $field.DerefResolvedType }}] {
	return {{ $field.Parent.Name }}QueryIdent[{{ $field.DerefResolvedType }}]{Ident: resource.NewIdent[{{ $field.DerefResolvedType }}]("{{ $field.Name }}", p.partialClause, {{ $field.IsIndex }})}
}
{{- end }}
{{- end }}
{{ end }}

type {{ .Resource.Name }}QueryClause struct {
	clause resource.QueryClause
}

func (qc {{ .Resource.Name }}QueryClause) And() {{ .Resource.Name }}QueryPartialClause {
	return {{ .Resource.Name }}QueryPartialClause{partialClause: qc.clause.And()}
}

func (qc {{ .Resource.Name }}QueryClause) Or() {{ .Resource.Name }}QueryPartialClause {
	return {{ .Resource.Name }}QueryPartialClause{partialClause: qc.clause.Or()}
}

type {{ .Resource.Name }}QueryIdent[T comparable] struct {
	resource.Ident[T]
}

func (i {{ .Resource.Name }}QueryIdent[T]) Equal(v ...T) {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.Equal(v...)}
}

func (i {{ .Resource.Name }}QueryIdent[T]) NotEqual(v ...T) {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.NotEqual(v...)}
}

func (i {{ .Resource.Name }}QueryIdent[T]) GreaterThan(v T) {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.GreaterThan(v)}
}

func (i {{ .Resource.Name }}QueryIdent[T]) GreaterThanEq(v T) {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.GreaterThanEq(v)}
}

func (i {{ .Resource.Name }}QueryIdent[T]) LessThan(v T) {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.LessThan(v)}
}

func (i {{ .Resource.Name }}QueryIdent[T]) LessThanEq(v T) {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.LessThanEq(v)}
}

func (i {{ .Resource.Name }}QueryIdent[T]) IsNull() {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.IsNull()}
}

func (i {{ .Resource.Name }}QueryIdent[T]) IsNotNull() {{ .Resource.Name }}QueryClause {
	return {{ .Resource.Name }}QueryClause{clause: i.Ident.IsNotNull()}
}

type {{ .Resource.Name }}SortBuilder struct {
	*{{ PrivateType .Resource.Name }}Sort
}

func New{{ .Resource.Name }}Sort() *{{ .Resource.Name }}SortBuilder {
	return &{{ .Resource.Name }}SortBuilder{ {{ PrivateType .Resource.Name }}Sort: &{{ PrivateType .Resource.Name }}Sort{}}
}

type {{ PrivateType .Resource.Name }}Sort struct {
	sortFields []resource.SortField
}

func (c *{{ PrivateType .Resource.Name }}Sort) addField(field string) *{{ .Resource.Name }}Sort {
	c.sortFields = append(c.sortFields, resource.SortField{Field: field, Direction: resource.SortAscending})

	return &{{ .Resource.Name }}Sort{ {{ PrivateType .Resource.Name }}Sort: c}
}

{{ range $field := .Resource.Fields }}
func (c *{{ PrivateType $field.Parent.Name }}Sort) {{ $field.Name }}() *{{ $field.Parent.Name }}Sort {
	return c.addField("{{ $field.Name }}")
}
{{ end }}

type {{ .Resource.Name }}Sort struct {
	*{{ PrivateType .Resource.Name }}Sort
}

func (s *{{ .Resource.Name }}Sort) Asc() *{{ .Resource.Name }}Sort {
	s.sortFields[len(s.sortFields)-1].Direction = resource.SortAscending

	return s
}

func (s *{{ .Resource.Name }}Sort) Desc() *{{ .Resource.Name }}Sort {
	s.sortFields[len(s.sortFields)-1].Direction = resource.SortDescending

	return s
}
{{- end }}

{{ if not .Resource.IsVirtual }}
type {{ .Resource.Name }}CreatePatch struct {
	patchSet *resource.PatchSet[{{ .Resource.Name }}]
}

{{ if .Resource.PrimaryKeyIsGeneratedUUID -}}
func New{{ .Resource.Name }}CreatePatchFromPatchSet(patchSet *resource.PatchSet[{{ .Resource.Name }}]) (*{{ .Resource.Name }}CreatePatch, error) {
	id, err := ccc.NewUUID()
	if err != nil {
		return nil, errors.Wrap(err, "ccc.NewUUID()")
	}
	
	patchSet.
		SetKey("{{ .Resource.PrimaryKey.Name }}", id).
		SetPatchType(resource.CreatePatchType)
	patch := &{{ .Resource.Name }}CreatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch, nil
}

func New{{ .Resource.Name }}CreatePatch() (*{{ .Resource.Name }}CreatePatch, error) {
	id, err := ccc.NewUUID()
	if err != nil {
		return nil, errors.Wrap(err, "ccc.NewUUID()")
	}
	
	patchSet := resource.NewPatchSet(resource.NewMetadata[{{ .Resource.Name }}]()).
		SetKey("{{ .Resource.PrimaryKey.Name }}", id).
		SetPatchType(resource.CreatePatchType)
	patch := &{{ .Resource.Name }}CreatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch, nil
}
{{ else }}
func New{{ .Resource.Name }}CreatePatchFromPatchSet(
{{- range $field := .Resource.Fields -}}
{{ if $field.IsPrimaryKey }}{{ GoCamel $field.Name }} {{ $field.ResolvedType }},{{ end }}
{{- end }} patchSet *resource.PatchSet[{{ .Resource.Name }}]) *{{ .Resource.Name }}CreatePatch {
	patchSet.
	{{ range $field := .Resource.Fields }}
	{{ if $field.IsPrimaryKey }}
	 	SetKey("{{ $field.Name }}", {{ GoCamel $field.Name }}).
	{{ end }}
	{{ end }}
		SetPatchType(resource.CreatePatchType)
	patch := &{{ .Resource.Name }}CreatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()
	
	return patch
}

func New{{ .Resource.Name }}CreatePatch(
{{- range $isNotFirstIteration, $field := .Resource.Fields }}
{{- if $field.IsPrimaryKey }}{{- if $isNotFirstIteration }}, {{ end }}{{ GoCamel $field.Name }} {{ $field.ResolvedType }}{{ end }}{{ end }}) *{{ .Resource.Name }}CreatePatch {
	patchSet := resource.NewPatchSet(resource.NewMetadata[{{ .Resource.Name }}]()).
	{{ range $field := .Resource.Fields }}
	{{ if $field.IsPrimaryKey }}
	 	SetKey("{{ $field.Name }}", {{ GoCamel $field.Name }}).
	{{ end }}
	{{ end }}
		SetPatchType(resource.CreatePatchType)
	patch := &{{ .Resource.Name }}CreatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch
}
{{ end }}

func (p *{{ .Resource.Name }}CreatePatch) Apply(ctx context.Context, client resource.Client, eventSource ...string) error {
	return p.patchSet.Apply(ctx, client, eventSource...)
}

func (p *{{ .Resource.Name }}CreatePatch) Buffer(ctx context.Context, txn resource.ReadWriteTransaction, eventSource ...string) error {
	return p.patchSet.Buffer(ctx, txn, eventSource...)
}

func (p *{{ .Resource.Name }}CreatePatch) registerDefaultFuncs() {
{{- range $field := .Resource.Fields }}
{{- if $field.HasDefaultCreateFunc }}
	p.patchSet.RegisterDefaultCreateFunc("{{ $field.Name }}", {{ $field.DefaultCreateFuncName }})
{{- end }}
{{- end }}
{{- if .Resource.HasDefaultsCreateType }}
	p.patchSet.RegisterDefaultsCreateFunc(func(ctx context.Context, txn resource.ReadWriteTransaction) error {
		return new({{ .Resource.DefaultsCreateType }}).Defaults(ctx, txn, p)
	})
{{- end }}
{{- if .Resource.HasValidateCreateType }}
	p.patchSet.RegisterValidateCreateFunc(func(ctx context.Context, txn resource.ReadWriteTransaction) error {
		return new({{ .Resource.ValidateCreateType }}).Validate(ctx, txn, p)
	})
{{- end }}
}

` + fieldAccessors(createPatch) + `

type {{ .Resource.Name }}UpdatePatch struct {
	patchSet *resource.PatchSet[{{ .Resource.Name }}]
}

func New{{ .Resource.Name }}UpdatePatchFromPatchSet(
{{- range $field := .Resource.Fields -}}
	{{- if $field.IsPrimaryKey -}}
		{{- GoCamel $field.Name }} {{ $field.ResolvedType }},
	{{- end -}}
{{- end -}}
patchSet *resource.PatchSet[{{ .Resource.Name }}]) *{{ .Resource.Name }}UpdatePatch {
	patchSet.
	{{ range $field := .Resource.Fields }}
		{{ if $field.IsPrimaryKey }}
		SetKey("{{ $field.Name }}", {{ GoCamel $field.Name }}).
		{{ end }}
	{{ end }}
		SetPatchType(resource.UpdatePatchType)

	patch := &{{ .Resource.Name }}UpdatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch
}

func New{{ .Resource.Name }}UpdatePatch(
{{- range $isNotFirstIteration, $field := .Resource.Fields -}}
	{{- if $field.IsPrimaryKey }}
		{{- if $isNotFirstIteration }}, {{ end -}}
		{{- GoCamel $field.Name }} {{ $field.ResolvedType }}
	{{- end -}}
{{- end }}) *{{ .Resource.Name }}UpdatePatch {
	patchSet := resource.NewPatchSet(resource.NewMetadata[{{ .Resource.Name }}]()).
{{- range $field := .Resource.Fields }}
	{{- if $field.IsPrimaryKey }}
		SetKey("{{ $field.Name }}", {{ GoCamel $field.Name }}).
	{{- end }}
{{- end }}
		SetPatchType(resource.UpdatePatchType)

	patch := &{{ .Resource.Name }}UpdatePatch{patchSet: patchSet}
	patch.registerDefaultFuncs()

	return patch
}

func (p *{{ .Resource.Name }}UpdatePatch) Apply(ctx context.Context, client resource.Client, eventSource ...string) error {
	return p.patchSet.Apply(ctx, client, eventSource...)
}

func (p *{{ .Resource.Name }}UpdatePatch) Buffer(ctx context.Context, txn resource.ReadWriteTransaction, eventSource ...string) error {
	return p.patchSet.Buffer(ctx, txn, eventSource...)
}

func (p *{{ .Resource.Name }}UpdatePatch) registerDefaultFuncs() {
{{- range $field := .Resource.Fields }}
{{- if $field.HasDefaultUpdateFunc }}
	p.patchSet.RegisterDefaultUpdateFunc("{{ $field.Name }}", {{ $field.DefaultUpdateFuncName }})
{{- end }}
{{- end }}
{{- if .Resource.HasDefaultsUpdateType }}
	p.patchSet.RegisterDefaultsUpdateFunc(func(ctx context.Context, txn resource.ReadWriteTransaction) error {
		return new({{ .Resource.DefaultsUpdateType }}).Defaults(ctx, txn, p)
	})
{{- end }}
{{- if .Resource.HasValidateUpdateType }}
	p.patchSet.RegisterValidateUpdateFunc(func(ctx context.Context, txn resource.ReadWriteTransaction) error {
		return new({{ .Resource.ValidateUpdateType }}).Validate(ctx, txn, p)
	})
{{- end }}
}

` + fieldAccessors(updatePatch) + `

type {{ .Resource.Name }}DeletePatch struct {
	patchSet *resource.PatchSet[{{ .Resource.Name }}]
}

func New{{ .Resource.Name }}DeletePatchFromPatchSet(
{{- range $field := .Resource.Fields -}}
	{{- if $field.IsPrimaryKey -}}
		{{- GoCamel $field.Name }} {{ $field.ResolvedType }},
	{{- end -}}
{{- end -}}
patchSet *resource.PatchSet[{{ .Resource.Name }}]) *{{ .Resource.Name }}DeletePatch {
	patchSet.
	{{ range $field := .Resource.Fields }}
		{{ if $field.IsPrimaryKey }}
		SetKey("{{ $field.Name }}", {{ GoCamel $field.Name }}).
		{{ end }}
	{{ end }}
		SetPatchType(resource.DeletePatchType)

	return &{{ .Resource.Name }}DeletePatch{patchSet: patchSet}
}

func New{{ .Resource.Name }}DeletePatch(
{{- range $isNotFirstIteration, $field := .Resource.Fields }}
	{{- if $field.IsPrimaryKey -}}
		{{- if $isNotFirstIteration }}, {{ end -}}
		{{- GoCamel $field.Name }} {{ $field.ResolvedType }}
	{{- end -}}
{{- end }}) *{{ .Resource.Name }}DeletePatch {
	patchSet := resource.NewPatchSet(resource.NewMetadata[{{ .Resource.Name }}]()).
{{- range $field := .Resource.Fields }}
		{{- if $field.IsPrimaryKey }}
		SetKey("{{ $field.Name }}", {{ GoCamel $field.Name }}).
		{{- end }}
{{- end }}
		SetPatchType(resource.DeletePatchType)

	return &{{ .Resource.Name }}DeletePatch{patchSet: patchSet}
}

func (p *{{ .Resource.Name }}DeletePatch) Apply(ctx context.Context, client resource.Client, eventSource ...string) error {
	return p.patchSet.Apply(ctx, client, eventSource...)
}

func (p *{{ .Resource.Name }}DeletePatch) Buffer(ctx context.Context, txn resource.ReadWriteTransaction, eventSource ...string) error {
	return p.patchSet.Buffer(ctx, txn, eventSource...)
}

{{ range $field := .Resource.Fields }}
{{ if $field.IsPrimaryKey }} 
func (p *{{ $field.Parent.Name }}DeletePatch) {{ $field.Name }}() {{ $field.ResolvedType }} {
	v, _ := p.patchSet.Key("{{ $field.Name }}").({{ $field.ResolvedType }}) 

	return v
}
{{ end }}
{{ end }}
{{ end }}`
)

const (
	handlerHeaderTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"context"
	"net/http"
	"time"

	{{ .LocalPackageImports }}
	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource"
	"github.com/cccteam/httpio"
	"github.com/go-playground/errors/v5"
)

{{ .Handlers }}`

	listTemplate = `func ({{ .ReceiverName }} *{{ .ApplicationName }}) {{ Pluralize .Resource.Name }}() http.HandlerFunc {
	type {{ GoCamel .Resource.Name }} struct {
		{{- range $field := .Resource.Fields }}
		{{ $field.Name }} {{ $field.Type}} ` + "`{{ $field.JSONTag }} {{ $field.IndexTag }} {{ $field.AllowFilterTag }} {{ $field.ListPermTag }} {{ $field.PIITag }}`" + `
		{{- end }}
	}

	type response []map[string]interface{}

	decoder := NewQueryDecoder[{{ if .Resource.IsVirtual }}{{ .VirtualResourcesPackage }}{{ else }}{{ .ResourcePackage }}{{ end }}.{{ .Resource.Name }}, {{ GoCamel .Resource.Name }}]({{ .ReceiverName }}, accesstypes.List)

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error {
		ctx, span := ccc.StartTrace(r.Context())
		defer span.End()

		querySet, err := decoder.Decode(r, {{ .ReceiverName }}.UserPermissions(r))
		if err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}

		res := {{ if .Resource.IsVirtual }}{{ .VirtualResourcesPackage }}{{ else }}{{ .ResourcePackage }}{{ end }}.New{{ .Resource.Name }}QueryFromQuerySet(querySet)

		resp := response{}
		for r, err := range res.List(ctx, {{ .ReceiverName }}.ResourceClient()) {
			if err != nil {
				return httpio.NewEncoder(w).ClientMessage(ctx, err)
			}
			rec := (*{{ GoCamel .Resource.Name }})(r)
			rmap := make(map[string]interface{})
			for _, field := range querySet.Fields() {
				switch string(field) {
				{{- range .Resource.Fields }}
				case "{{ .Name }}":
					rmap["{{ Camel .Name }}"] = rec.{{ .Name }}
				{{- end }}
				}
			}
			resp = append(resp, rmap)
		}

		return httpio.NewEncoder(w).Ok(resp)
	})
}`

	readTemplate = `func ({{ .ReceiverName }} *{{ .ApplicationName }}) {{ .Resource.Name }}() http.HandlerFunc {
	type response struct {
		{{- range $field := .Resource.Fields }}
		{{ $field.Name }} {{ $field.Type}} ` + "`{{ $field.JSONTag }} {{ $field.UniqueIndexTag }} {{ $field.ReadPermTag }} {{ $field.PIITag }}`" + `
		{{- end }}
	}

	decoder := NewQueryDecoder[{{ if .Resource.IsVirtual }}{{ .VirtualResourcesPackage }}{{ else }}{{ .ResourcePackage }}{{ end }}.{{ .Resource.Name }}, response]({{ .ReceiverName }}, accesstypes.Read)

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error {
		ctx, span := ccc.StartTrace(r.Context())
		defer span.End()

	{{ if .Resource.HasCompoundPrimaryKey }}
	{{- range $_, $field := .Resource.PrimaryKeys }}
		{{ GoCamel $field.Name }} := httpio.Param[{{ $field.Type }}](r, router.{{ $.Resource.Name }}{{ $field.Name }})
	{{- end }}
	{{ else }}
		id := httpio.Param[{{ .Resource.PrimaryKeyType }}](r, router.{{ .Resource.Name }}ID)
	{{ end }}
		querySet, err := decoder.Decode(r, {{ .ReceiverName }}.UserPermissions(r))
		if err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}

	{{ if .Resource.HasCompoundPrimaryKey }}
		res := {{ if .Resource.IsVirtual }}{{ .VirtualResourcesPackage }}{{ else }}{{ .ResourcePackage }}{{ end }}.New{{ .Resource.Name }}QueryFromQuerySet(querySet){{ range $_, $field := .Resource.PrimaryKeys }}.Set{{ $field.Name }}({{ GoCamel $field.Name }}){{ end }}
	{{- else }}
		res := {{ if .Resource.IsVirtual }}{{ .VirtualResourcesPackage }}{{ else }}{{ .ResourcePackage }}{{ end }}.New{{ .Resource.Name }}QueryFromQuerySet(querySet).Set{{ .Resource.PrimaryKey.Name }}(id)
	{{- end }}

		row, err := res.Read(ctx, {{ .ReceiverName }}.ResourceClient())
		if err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}
		rec := (*response)(row)
		rmap := make(map[string]interface{})
		for _, field := range querySet.Fields() {
			switch string(field) {
			{{- range .Resource.Fields }}
			case "{{ .Name }}":
				rmap["{{ Camel .Name }}"] = rec.{{ .Name }}
			{{- end }}
			}
		}

		return httpio.NewEncoder(w).Ok(rmap)
	})
}`

	patchTemplate = `func ({{ .ReceiverName }} *{{ .ApplicationName }}) Patch{{ Pluralize .Resource.Name }}() http.HandlerFunc {
	type request struct {
		{{- range $field := .Resource.Fields }}
		{{ $field.Name }} {{ $field.Type}} ` + "`{{ $field.JSONTagForPatch }} {{ $field.ImmutableTag }} {{ $field.PatchPermTag }}`" + `
		{{- end }}
	}
	
	{{ $PrimaryKeyIsGeneratedUUID := .Resource.PrimaryKeyIsGeneratedUUID }}
	{{ $PrimaryKeyType := .Resource.PrimaryKeyType }}
	{{- if $PrimaryKeyIsGeneratedUUID }}
	type response struct {
		IDs []ccc.UUID ` + "`json:\"iDs\"`" + `
	}
	{{- end }}

	decoder := NewDecoder[{{ .ResourcePackage }}.{{ .Resource.Name }}, request]({{ .ReceiverName }}, accesstypes.Create, accesstypes.Update, accesstypes.Delete)

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error {
		ctx, span := ccc.StartTrace(r.Context())
		defer span.End()

		{{ if $PrimaryKeyIsGeneratedUUID }}
		var resp response
		{{- end }}
		eventSource := resource.UserEvent(ctx)

		if err := {{ .ReceiverName }}.ResourceClient().ExecuteFunc(ctx, func(ctx context.Context, txn resource.ReadWriteTransaction) error {
			{{- if $PrimaryKeyIsGeneratedUUID }}
			resp = response{}
			{{- end }}
			r, err := resource.CloneRequest(r)
			if err != nil {
				return errors.Wrap(err, "resource.CloneRequest()")
			}

			for op, err := range resource.Operations(r, "{{ .Resource.OperationPathPattern }}"{{ if not $PrimaryKeyIsGeneratedUUID }}, resource.RequireCreatePath(){{ end }}) {
				if err != nil {
					return errors.Wrap(err, "resource.Operations()")
				}

				patchSet, err := decoder.DecodeOperation(op, {{ .ReceiverName }}.UserPermissions(r))
				if err != nil {
					return errors.Wrap(err, "decoder.DecodeOperation()")
				}

				switch op.Type {
				case resource.OperationCreate:
				{{- if $PrimaryKeyIsGeneratedUUID }}
					patch, err := {{ .ResourcePackage }}.New{{ .Resource.Name }}CreatePatchFromPatchSet(patchSet)
					if err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.New{{ .Resource.Name }}CreatePatchFromPatchSet()")
					}
					if err := patch.Buffer(ctx, txn, eventSource); err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.{{ .Resource.Name }}CreatePatch.Buffer()")
					}
					resp.IDs = append(resp.IDs, patch.{{ .Resource.PrimaryKey.Name }}())
				{{- else if .Resource.HasCompoundPrimaryKey }}
					{{- range $i, $field := .Resource.PrimaryKeys }}
					id{{ $i }} := httpio.Param[{{ $field.Type }}](op.Req, "id{{ $i }}")
					{{- end }}
					if err := {{ .ResourcePackage }}.New{{ .Resource.Name }}CreatePatchFromPatchSet({{- range $i := .Resource.PrimaryKeys }}id{{ $i }}, {{ end }}patchSet).Buffer(ctx, txn, eventSource); err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.{{ .Resource.Name }}CreatePatch.Buffer()")
					}
				{{- else }}
					id := httpio.Param[{{ $PrimaryKeyType }}](op.Req, "id")
					if err := {{ .ResourcePackage }}.New{{ .Resource.Name }}CreatePatchFromPatchSet(id, patchSet).Buffer(ctx, txn, eventSource); err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.{{ .Resource.Name }}CreatePatch.Buffer()")
					}
				{{- end }}
				case resource.OperationUpdate:
				{{- if .Resource.HasCompoundPrimaryKey }}
					{{- range $i, $field := .Resource.PrimaryKeys }}
					id{{ $i }} := httpio.Param[{{ $field.Type }}](op.Req, "id{{ $i }}")
					{{- end }}
					if err := {{ .ResourcePackage }}.New{{ .Resource.Name }}UpdatePatchFromPatchSet({{- range $i := .Resource.PrimaryKeys }}id{{ $i }}, {{ end }}patchSet).Buffer(ctx, txn, eventSource); err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.{{ .Resource.Name }}UpdatePatch.Buffer()")
					}
				{{- else }}
					id := httpio.Param[{{ $PrimaryKeyType }}](op.Req, "id")
					if err := {{ .ResourcePackage }}.New{{ .Resource.Name }}UpdatePatchFromPatchSet(id, patchSet).Buffer(ctx, txn, eventSource); err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.{{ .Resource.Name }}UpdatePatch.Buffer()")
					}
				{{- end }}
				case resource.OperationDelete:
				{{- if .Resource.HasCompoundPrimaryKey }}
					{{- range $i, $field := .Resource.PrimaryKeys }}
						id{{ $i }} := httpio.Param[{{ $field.Type }}](op.Req, "id{{ $i }}")
					{{- end }}
					if err := {{ .ResourcePackage }}.New{{ .Resource.Name }}DeletePatchFromPatchSet({{- range $i := .Resource.PrimaryKeys }}id{{ $i }}, {{ end }}patchSet).Buffer(ctx, txn, eventSource); err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.{{ .Resource.Name }}DeletePatch.Buffer()")
					}
				{{- else }}
					id := httpio.Param[{{ $PrimaryKeyType }}](op.Req, "id")
					if err := {{ .ResourcePackage }}.New{{ .Resource.Name }}DeletePatchFromPatchSet(id, patchSet).Buffer(ctx, txn, eventSource); err != nil {
						return errors.Wrap(err, "{{ .ResourcePackage }}.{{ .Resource.Name }}DeletePatch.Buffer()")
					}
				{{- end }}
				}
			}

			return nil
		}); err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, handleError[{{ .ResourcePackage }}.{{ .Resource.Name }}](err))
		}

		{{ if $PrimaryKeyIsGeneratedUUID  }}
		return httpio.NewEncoder(w).Ok(resp)
		{{ else }}
		return httpio.NewEncoder(w).Ok(nil)
		{{- end -}}
	})
}`

	consolidatedPatchTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"context"
	"net/http"
	"time"

	{{ .LocalPackageImports }}
	"cloud.google.com/go/civil"
	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource"
	"github.com/cccteam/httpio"
)

func ({{ .ReceiverName }} *{{ .ApplicationName }}) PatchResources() http.HandlerFunc {
	{{- $resourcePackage := .ResourcePackage -}}
	{{- range $resource := .Resources }}
	type {{ GoCamel $resource.Name }}Request struct {
		{{- range $field := .Fields }}
		{{ $field.Name }} {{ $field.Type}} ` + "`{{ $field.JSONTagForPatch }} {{ $field.ImmutableTag }} {{ $field.PatchPermTag }}`" + `
		{{- end }}
	}
	{{ GoCamel $resource.Name}}Decoder := NewDecoder[{{ $resourcePackage }}.{{ $resource.Name }}, {{ GoCamel $resource.Name }}Request]({{ $.ReceiverName }}, accesstypes.Create, accesstypes.Update, accesstypes.Delete)
	{{ end }}

	type response map[string][]ccc.UUID

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error {
		ctx, span := ccc.StartTrace(r.Context())
		defer span.End()

		var (
			eventSource = resource.UserEvent(ctx)
			resp    response
		)

		if err := {{ .ReceiverName }}.ResourceClient().ExecuteFunc(ctx, func(ctx context.Context, txn resource.ReadWriteTransaction) error {
			resp = response{}
			r, err := resource.CloneRequest(r)
			if err != nil {
				return errors.Wrap(err, "resource.CloneRequest()")
			}

			for op, err := range resource.Operations(r, "/{resource}", resource.MatchPrefix()) {
				if err != nil {
					return errors.Wrap(err, "resource.Operations()")
				}

				switch httpio.Param[string](op.Req, "resource") {
					{{- range $resource := .Resources -}}
					{{- $primaryKeyType := $resource.PrimaryKeyType }}
					case "{{ Kebab (Pluralize $resource.Name) }}":
						patchSet, err := {{ GoCamel $resource.Name}}Decoder.DecodeOperation(op, {{ $.ReceiverName }}.UserPermissions(op.Req))
						if err != nil {
							return errors.Wrap(err, "{{ GoCamel $resource.Name}}Decoder.DecodeOperation()")
						}

						req, err := op.ReqWithPattern("/{resource}{{ $resource.OperationPathPattern }}"{{ if not $resource.PrimaryKeyIsGeneratedUUID }}, resource.RequireCreatePath(){{ end }})
						if err != nil {
							return errors.Wrap(err, "op.ReqWithPattern()")
						}

						switch op.Type {
						case resource.OperationCreate:
						{{- if $resource.PrimaryKeyIsGeneratedUUID }}
							patch, err := {{ $resourcePackage }}.New{{ $resource.Name }}CreatePatchFromPatchSet(patchSet)
							if err != nil {
								return errors.Wrap(err, "{{ GoCamel $resource.Name}}CreatePatchFromPatchSet()")
							}
							if err := patch.Buffer(ctx, txn, eventSource); err != nil {
								return errors.Wrap(handleError[{{ $resourcePackage }}.{{ $resource.Name }}](err), "{{ $resourcePackage }}.{{ $resource.Name }}CreatePatch.Buffer()")
							}
							resp["{{ GoCamel (Pluralize .Name) }}"] = append(resp["{{ GoCamel (Pluralize .Name) }}"], patch.{{ $resource.PrimaryKey.Name }}())
						{{- else if $resource.HasCompoundPrimaryKey }}
							{{- range $i, $field := $resource.PrimaryKeys }}
							id{{ $i }} := httpio.Param[{{ $field.Type }}](req, "id{{ $i }}")
							{{- end }}
							if err := {{ $resourcePackage }}.New{{ $resource.Name }}CreatePatchFromPatchSet({{- range $i := $resource.PrimaryKeys }}id{{ $i }}, {{ end }}patchSet).Buffer(ctx, txn, eventSource); err != nil {
								return errors.Wrap(handleError[{{ $resourcePackage }}.{{ $resource.Name }}](err), "{{ $resourcePackage }}.{{ $resource.Name }}CreatePatch.Buffer()")
							}
						{{- else }}
							id := httpio.Param[{{ $primaryKeyType }}](req, "id")
							if err := {{ $resourcePackage }}.New{{ $resource.Name }}CreatePatchFromPatchSet(id, patchSet).Buffer(ctx, txn, eventSource); err != nil {
								return errors.Wrap(handleError[{{ $resourcePackage }}.{{ $resource.Name }}](err), "{{ $resourcePackage }}.{{ $resource.Name }}CreatePatch.Buffer()")
							}
						{{- end }}
						case resource.OperationUpdate:
							{{- if $resource.HasCompoundPrimaryKey }}
							{{- range $i, $field := $resource.PrimaryKeys }}
							id{{ $i }} := httpio.Param[{{ $field.Type }}](req, "id{{ $i }}")
							{{- end }}
							if err := {{ $resourcePackage }}.New{{ $resource.Name }}UpdatePatchFromPatchSet({{- range $i := $resource.PrimaryKeys }}id{{ $i }}, {{ end }}patchSet).Buffer(ctx, txn, eventSource); err != nil {
								return errors.Wrap(handleError[{{ $resourcePackage }}.{{ $resource.Name }}](err), "{{ $resourcePackage }}.{{ $resource.Name }}UpdatePatch.Buffer()")
							}
							{{- else}}
							id := httpio.Param[{{ $primaryKeyType }}](req, "id")
							if err := {{ $resourcePackage }}.New{{ $resource.Name }}UpdatePatchFromPatchSet(id, patchSet).Buffer(ctx, txn, eventSource); err != nil {
								return errors.Wrap(handleError[{{ $resourcePackage }}.{{ $resource.Name }}](err), "{{ $resourcePackage }}.{{ $resource.Name }}UpdatePatch.Buffer()")
							}
							{{- end }}
						case resource.OperationDelete:
							{{- if $resource.HasCompoundPrimaryKey }}
							{{- range $i, $field := $resource.PrimaryKeys }}
							id{{ $i }} := httpio.Param[{{ $field.Type }}](req, "id{{ $i }}")
							{{- end }}
							if err := {{ $resourcePackage }}.New{{ $resource.Name }}DeletePatchFromPatchSet({{- range $i := $resource.PrimaryKeys }}id{{ $i }}, {{ end }}patchSet).Buffer(ctx, txn, eventSource); err != nil {
								return errors.Wrap(handleError[{{ $resourcePackage }}.{{ $resource.Name }}](err), "{{ $resourcePackage }}.{{ $resource.Name }}DeletePatch.Buffer()")
							}
							{{- else }}
							id := httpio.Param[{{ $primaryKeyType }}](req, "id")
							if err := {{ $resourcePackage }}.New{{ $resource.Name }}DeletePatchFromPatchSet(id, patchSet).Buffer(ctx, txn, eventSource); err != nil {
								return errors.Wrap(handleError[{{ $resourcePackage }}.{{ $resource.Name }}](err), "{{ $resourcePackage }}.{{ $resource.Name }}DeletePatch.Buffer()")
							}
							{{- end }}
						}
					{{- end }}
				default:
					return httpio.NewBadRequestMessagef("unknown resource %q", httpio.Param[string](op.Req, "resource"))
				}
			}

			return nil
		}); err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}

		return httpio.NewEncoder(w).Ok(resp)
	})
}`

	resourceEnumsTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

{{ range $namedType := .NamedTypes }}
{{ if $enums := index $.EnumMap $namedType.Name }}
const (
	{{ range $enum := $enums -}}
	{{ SanitizeIdentifier $enum.Description }}{{ $namedType.Name }} {{ $namedType.Name }} = {{ printf "%q" $enum.ID }}
	{{ end -}}
)
{{- end }}
{{- end }}
`

	typescriptConstantsTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
import { {{ TypescriptConstImports .File .Data }} } from '@cccteam/ccc-lib';

{{- $permissions := .Data.Permissions }}
{{- $resourcePermissions := .Data.ResourcePermissions }}
{{- $resources := .Data.Resources }}
{{- $resourcetags := .Data.ResourceTags }}
{{- $resourcePermMap := .Data.ResourcePermissionMap }}
{{- $domains := .Data.Domains }}
{{- $rpcMethods := .RPCMethods }}

export const Permissions = {
{{- range $perm := $permissions }}
  {{ $perm }}: '{{ $perm }}' as Permission,
{{- end}}
};

export const Domains = {
{{- range $domain := $domains }}
  {{ $domain }}: '{{ $domain }}' as Domain,
{{- end}}
};

export const Resources = {
{{- range $resource := $resources }}
  {{ $resource }}: '{{ $resource }}' as Resource,
{{- end}}
};

export const Methods = {
{{- range $rpcMethod := $rpcMethods }}
  {{ $rpcMethod.Name }}: '{{ $rpcMethod.Name }}' as Method,
{{- end }}
};

{{ range $resource, $tags := $resourcetags }}
export namespace {{ $resource }} {
  export const fieldName = {
  {{- range $_, $tag := $tags }}
  {{- if not (index $.PIIMap $resource $tag) }}
    {{ $tag }}: '{{ $tag }}' as FieldName,
  {{- end }}
  {{- end }}
  };
  {{- if index $.PIIMap $resource }}
  export const piiFieldName = {
  {{- range $_, $tag := $tags }}
  {{- if index $.PIIMap $resource $tag }}
    {{ $tag }}: '{{ $tag }}' as FieldName,
  {{- end }}
  {{- end }}
  };
  {{- end }}
  export const resourceName = {
  {{- range $_, $tag := $tags }}
    {{ $tag }}: '{{ $resource.ResourceWithTag $tag }}' as Resource,
  {{- end }}
  };
};
{{ end }}
{{ range $rpcMethod := $rpcMethods }}
export namespace {{ $rpcMethod.Name }} {
  export const fieldName = {
  {{- range $field := $rpcMethod.Fields }}
    {{ Camel $field.Name }}: '{{ Camel $field.Name }}' as FieldName,
  {{- end }}
  };
};
{{ end }}
type ResourcePermissions = Record<Permission, boolean>;
type PermissionMappings = Record<Resource, ResourcePermissions>;

const Mappings: PermissionMappings = {
  {{- range $resource := $resources }}
  [Resources.{{ $resource }}]: {
    {{- range $perm := $resourcePermissions }}
    [Permissions.{{ $perm }}]: {{ index $resourcePermMap $resource $perm }},
    {{- end }}
  },
    {{- range $tag := index $resourcetags $resource }}
  [{{ $resource }}.resourceName.{{ $tag }}]: {
      {{- range $perm := $resourcePermissions }}
    [Permissions.{{ $perm }}]: {{ index $resourcePermMap ($resource.ResourceWithTag $tag) $perm }},
      {{- end }}
  },
    {{- end }}
  {{- end }}
};

export function requiresPermission(resource: Resource, permission: Permission): boolean {
  return Mappings[resource]?.[permission] ?? false;
}

{{ with $rpcMethods := .RPCMethods -}}
type MethodPermissions = Record<Permission, boolean>;
type MethodPermissionMappings = Record<Method, MethodPermissions>;

const MethodMappings: MethodPermissionMappings = {
  {{- range $rpcMethod := $rpcMethods }}
  [Methods.{{ $rpcMethod.Name }}]: {
    [Permissions.Execute]: true,
  },
  {{- end }}
};

export function requiresMethodPermission(resource: Method, permission: Permission): boolean {
  return MethodMappings[resource]?.[permission] ?? false;
}
{{- end }}
`

	typescriptResourcesTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
import { Resource } from '@cccteam/ccc-lib';
import { ResourceMap, ResourceMeta{{ if .File.HasNullBoolean }}, NullBoolean{{ end }}{{ if .File.HasCustomTypesInResources }}, CustomTypes{{ end }} } from '@components/Resource/resources-helpers';
import { Resources } from './{{ .GenPrefix }}_constants';
{{ range $resource := .Resources }}
export interface {{ Pluralize $resource.Name }} {
{{- range $field := $resource.Fields }}
  {{ Camel $field.Name }}: {{ $field.TypescriptDataType }};
{{- end }}
}
{{ end }}
{{- range $resource := .ComputedResources }}
export interface {{ Pluralize $resource.Name }} {
{{- range $field := $resource.Fields }}
  {{ Camel $field.Name }}: {{ $field.TypescriptDataType }};
{{- end }}
}
{{ end }}
{{ $consolidatedRoute := .ConsolidatedRoute -}}
const resourceMap: ResourceMap = {
  {{- range $resource := $.Resources }}
  [Resources.{{ Pluralize $resource.Name }}]: {
    route: '{{ Kebab (Pluralize $resource.Name) }}',
    {{- if eq $resource.IsConsolidated true }}
    consolidatedRoute: '{{ $consolidatedRoute }}',
    {{- end }}
	{{- if eq $resource.ListHandlerDisabled true }}
    listDisabled: true,
    {{- end }}
	{{- if eq $resource.ReadHandlerDisabled true }}
    readDisabled: true,
    {{- end }}
	{{- if eq $resource.CreateHandlerDisabled true }}
    createDisabled: true,
    {{- end }}
	{{- if eq $resource.UpdateHandlerDisabled true }}
    updateDisabled: true,
    {{- end }}
	{{- if eq $resource.DeleteHandlerDisabled true }}
    deleteDisabled: true,
    {{- end }}
    fields: [
      {{- range $field := $resource.Fields }}
      { fieldName: '{{ Camel $field.Name }}', 
       {{- if $field.IsPrimaryKey }} primaryKey: { ordinalPosition: {{ $field.KeyOrdinalPosition }} }, 
       {{- end }} displayType: '{{ Lower $field.TypescriptDisplayType }}', required: {{ $field.IsRequired }}, isIndex: {{ $field.IsIndex -}}
      {{- if $field.IsEnumerated }}, enumeratedResource: Resources.{{ $field.ReferencedResource }}{{ end }} },
      {{- end }}
    ],
  },

  {{- end }}
  {{- range $resource := $.ComputedResources }}
  [Resources.{{ Pluralize $resource.Name }}]: {
    route: '{{ Kebab (Pluralize $resource.Name) }}',
	{{- if $resource.SuppressListHandler }}listDisabled: true, {{ end }}
	{{- if $resource.SuppressReadHandler }}readDisabled: true, {{ end -}}
	createDisabled: true, updateDisabled: true, deleteDisabled: true,
    fields: [
      {{- range $field := $resource.Fields }}
      { fieldName: '{{ Camel $field.Name }}', 
       {{- if $field.IsPrimaryKey }} primaryKey: { ordinalPosition: {{ $field.KeyOrdinalPosition }} }, 
       {{- end }} displayType: '{{ Lower $field.TypescriptDataType }}', required: {{ $field.IsPrimaryKey }}, isIndex: false },
      {{- end }}
    ],
  },

  {{- end }}
}

export function resourceMeta(resource: Resource): ResourceMeta {
  if (resourceMap[resource] !== undefined) {
    return resourceMap[resource];
  } else {
    console.error('Resource not found in resourceMap:', resource);
    return {} as ResourceMeta;
  }
}
`

	typescriptMethodsTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
import { FieldName, Method, Resource } from '@cccteam/ccc-lib';
import { Meta, ValidRPCTypes{{ if .File.HasCustomTypesInMethods }}, CustomTypes{{ end }} } from '@components/Resource/resources-helpers';
{{- $imports := (TypescriptMethodImports .File) }}{{ if ne $imports "" }}
import { {{ $imports }} } from './{{ .GenPrefix }}_constants';
{{- end }}

export interface FieldPointer {
  field: FieldName;
}
{{ range $rpcMethod := .RPCMethods }}
export interface {{ $rpcMethod.Name }}Config {
{{- range $field := $rpcMethod.Fields }}
  {{ Camel $field.Name }}: {{ $field.TypescriptDataType }} | FieldPointer;
{{- end }}
}
export interface {{ $rpcMethod.Name }} {
{{- range $field := $rpcMethod.Fields }}
  {{ Camel $field.Name }}: {{ $field.TypescriptDataType }};
{{- end }}
}
{{ end }}
export interface RPCFieldMeta {
  fieldName: string;
  displayType: ValidRPCTypes;
  enumeratedResource?: Resource;
}

export interface MethodMeta {
  route: string;
  fields: RPCFieldMeta[];
}

export type MethodMap = Record<Method, MethodMeta>;

const methodMap: MethodMap = {
  {{- range $rpcMethod := .RPCMethods }}
  [Methods.{{ $rpcMethod.Name }}]: {
    route: '{{ Kebab ($rpcMethod.Name) }}',
  {{- if gt $rpcMethod.NumFields 0 }}
    fields: [
    {{- range $field := $rpcMethod.Fields }}
      { fieldName: '{{ Camel $field.Name }}', displayType: '{{ Lower $field.TypescriptDisplayType }}'{{- if $field.IsEnumerated }}, enumeratedResource: Resources.{{ $field.EnumeratedResource }}{{ end }} },
    {{- end }}
    ],
  {{- end }}
  },

  {{- end }}
};

export function methodMeta(method: Method): Meta {
  if (methodMap[method] !== undefined) {
    return methodMap[method];
  } else {
    console.error('Method not found in methodMap:', method);
    return {} as Meta;
  }
}
`

	typescriptEnumsTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}
{{ range $namedType := .NamedTypes -}}
{{ if $enums := index $.EnumMap $namedType.Name }}
export enum {{ $namedType.Name }} {
{{ range $enum := $enums }}  {{ SanitizeIdentifier $enum.Description }} = {{ printf "'%s'" $enum.ID }},
{{ end -}}
}
{{ end }}
{{- end }}

`

	routesTemplate = `// Code generated by spannergen. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"net/http"

	"github.com/cccteam/httpio"
	"github.com/go-chi/chi/v5"
)

const (
{{- range $resource := .Resources }}
{{- if $resource.HasCompoundPrimaryKey }}
	{{- range $_, $field := $resource.PrimaryKeys }}
	{{ $resource.Name }}{{ $field.Name }} httpio.ParamType = "{{ GoCamel $resource.Name }}{{ $field.Name }}"
	{{- end }}
{{- else }}
	{{ $resource.Name }}ID httpio.ParamType = "{{ GoCamel $resource.Name }}ID"
{{- end }}
{{- end }}
{{- range $resource := .ComputedResources }}
	{{- range $_, $field := $resource.PrimaryKeys }}
	{{ $resource.Name }}{{ $field.Name }} httpio.ParamType = "{{ GoCamel $resource.Name }}{{ $field.Name }}"
	{{- end }}
{{- end }}
)

type GeneratedHandlers interface {
	{{ range $Struct, $Routes := .RoutesMap }}{{ range $Routes }}{{ .HandlerFunc }}() http.HandlerFunc
	{{ end }}
	{{ end -}}
	{{- if .HasConsolidatedHandler }}PatchResources() http.HandlerFunc{{ end }}
}

func generatedRoutes(r chi.Router, h GeneratedHandlers) {
{{- range $Struct, $Routes := .RoutesMap }}
	{{- range $route := $Routes }}
	{{- if $route.SharedHandler }}
	{{ Camel $route.HandlerFunc }}Handler := h.{{ $route.HandlerFunc }}()
	r.{{ Pascal $route.Method }}("{{ $route.Path }}", {{ Camel $route.HandlerFunc }}Handler)
	r.Post("{{ $route.Path }}", {{ Camel $route.HandlerFunc }}Handler)
	{{ else }}
	r.{{ Pascal $route.Method }}("{{ $route.Path }}", h.{{ $route.HandlerFunc }}())
	{{ end }}
	{{ end }}
{{ end }}
{{ if .HasConsolidatedHandler }}r.Patch("/{{ .RoutePrefix }}/{{ .ConsolidatedRoute }}", h.PatchResources()){{ end }}
}`

	routerTestTemplate = `// Code generated by handlergen. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"net/http"

	{{ .LocalPackageImports }}
)

type generatedRouterTest struct {
	url string
	method string
	handlerFunc string
	parameters map[string]string
}

func generatedRouteParameters() []string {
	keys := []string {
	{{- range $resource := .Resources }}
	{{- if $resource.HasCompoundPrimaryKey }}
		{{- range $_, $field := $resource.PrimaryKeys }}
		"{{ GoCamel $resource.Name }}{{ $field.Name }}",
		{{- end }}
	{{- else }}
		"{{ GoCamel $resource.Name }}ID",
	{{- end }}
	{{- end }}
	{{- range $resource := .ComputedResources }}
	{{- if $resource.HasCompoundPrimaryKey }}
		{{- range $_, $field := $resource.PrimaryKeys }}
		"{{ GoCamel $resource.Name }}{{ $field.Name }}",
		{{- end }}
	{{- else if $resource.PrimaryKey }}
		"{{ GoCamel $resource.Name }}{{ $resource.PrimaryKey.Name }}",
	{{- end }}
	{{- end }}
	}

	return keys
}

{{ $routePrefix := .RoutePrefix -}}
func generatedRouterTests() []*generatedRouterTest {
	routerTests := []*generatedRouterTest {
		{{- range $resource := .Resources }}
		{{- range $route := (index $.RoutesMap $resource.Name) }}
		{
			url: "{{ DetermineTestURL $resource $routePrefix $route }}", method: {{ MethodToHttpConst $route.Method }},
			handlerFunc: "{{ $route.HandlerFunc }}",
			parameters: {{ DetermineParameters $resource $route }},
		},
		{{- if $route.SharedHandler }}
		{
			url: "{{ DetermineTestURL $resource $routePrefix $route }}", method: http.MethodPost,
			handlerFunc: "{{ $route.HandlerFunc }}",
			parameters: {{ DetermineParameters $resource $route }},
		},
		{{- end }}
		{{- end }}
		{{- end }}
		{{- range $resource := .ComputedResources }}
		{{- range $route := (index $.RoutesMap $resource.Name) }}
		{
			url: "/{{ $routePrefix }}/{{ Kebab (Pluralize $resource.Name) }}{{ if eq $route.HandlerType "readHandler" }}{{ range $_, $field := $resource.PrimaryKeys }}/test{{ Pascal $resource.Name }}{{ $field.Name }}{{ end }}{{ end }}", method: {{ MethodToHttpConst $route.Method }},
			handlerFunc: "{{ $route.HandlerFunc }}",
			parameters: map[string]string{
			{{- range $_, $field := $resource.PrimaryKeys }}{{ if eq $route.HandlerType "readHandler" -}}
			"{{ GoCamel $resource.Name }}{{ $field.Name }}": "test{{ Pascal $resource.Name }}{{ $field.Name }}",
			{{- end }}{{ end -}}
			},
		},
		{{- if $route.SharedHandler }}
		{
			url: "/{{ $routePrefix }}/{{ Kebab (Pluralize $resource.Name) }}{{ if eq $route.HandlerType "readHandler" }}{{ range $_, $field := $resource.PrimaryKeys }}/test{{ Pascal $resource.Name }}{{ $field.Name }}{{ end }}{{ end }}", method: http.MethodPost,
			handlerFunc: "{{ $route.HandlerFunc }}",
			parameters: map[string]string{
			{{- range $_, $field := $resource.PrimaryKeys }}{{ if eq $route.HandlerType "readHandler" -}}
			"{{ GoCamel $resource.Name }}{{ $field.Name }}": "test{{ Pascal $resource.Name }}{{ $field.Name }}",
			{{- end }}{{ end -}}
			},
		},
		{{- end }}
		{{- end }}
		{{- end }}
		{{- if .HasConsolidatedHandler }}
		{
			url: "/{{ .RoutePrefix }}/{{ .ConsolidatedRoute }}", method: http.MethodPatch,
			handlerFunc: "PatchResources",
		},
		{{ end }}
	}

	return routerTests
}

func generatedExpectCalls(e *mock_router.MockHandlersMockRecorder, rec *callRecorder) {
	{{ range $Struct, $Routes := .RoutesMap }}{{ range $Routes }}e.{{ .HandlerFunc }}().Times(1).Return(rec.RecordHandlerCall("{{ .HandlerFunc }}"))
	{{ end }}{{- end -}}
	{{- if eq .HasConsolidatedHandler true }}e.PatchResources().Times(1).Return(rec.RecordHandlerCall("PatchResources")){{ end -}}
}`

	rpcFileTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source {{ .Source }}

package {{ .Package }}

import (
	"github.com/cccteam/ccc/resource"
)

func ({{ .RPCMethod.Name }}) Method() accesstypes.Resource {
	return "{{ .RPCMethod.Name }}"
}
`

	rpcHandlerTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"net/http"
	"time"

	{{ .LocalPackageImports }}
	cloudspanner "cloud.google.com/go/spanner"
	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource"
	"github.com/cccteam/httpio"
	"github.com/shopspring/decimal"
)

func ({{ .ReceiverName }} *{{ .ApplicationName }}) {{ .RPCMethod.Name }}() http.HandlerFunc {
	{{- range $field := .RPCMethod.Fields }}
	{{- if $field.IsLocalType }}
	type {{ Lower $field.UnqualifiedTypeName }} 
	
	{{- with $field.AsStruct }} struct {
		{{- range $field := .Fields }}
		{{ $field.Name }} {{ $field.Type }} ` + "`json:\"{{ Camel $field.Name }}\"`" + `
		{{- end }}
	}
	{{ else }} {{ $field.Type }}
	{{ end }}
	{{ end -}}
	{{ end }}
	type request struct {
		{{- range $field := .RPCMethod.Fields }}
		{{ $field.Name }} {{ if $field.IsLocalType }}{{ Lower $field.UnqualifiedType }}{{ else }}{{ $field.Type }}{{ end }} ` + "`{{ $field.JSONTag }}`" + `
		{{- end }}
	}

	decoder := NewRPCDecoder[{{ .RPCMethod.Type }}, request]({{ .ReceiverName }}, accesstypes.Execute)

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error { 
		ctx, span := ccc.StartTrace(r.Context())
		defer span.End()

		params, err := decoder.Decode(r)
		if err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}

		{{- if .RPCMethod.HasLocalType }}
		p := &{{ .RPCMethod.Type }}{
			{{- range $field := .RPCMethod.Fields }}
			{{- if not $field.IsIterable }}
			{{ $field.Name }}: params.{{ $field.Name }},
			{{- end -}}
			{{- end }}
		}
		{{- range $field := .RPCMethod.Fields -}}
		{{- if $field.IsIterable }}
		for _, e := range params.{{ $field.Name }} {
			p.{{ $field.Name }} = append(p.{{ $field.Name }}, {{ $field.TypeName }}(e))
		}
		{{- end }}
		{{- end }}
		{{- else }}

		p := (*{{ .RPCMethod.Type }})(params)
		{{- end }}
		{{- if .RPCMethod.IsTxnRunner }}
			if err := {{ $.ReceiverName }}.ResourceClient().ExecuteFunc(ctx, func(ctx context.Context, txn resource.ReadWriteTransaction) error {
				if err := p.Execute(ctx, txn, {{ $.ReceiverName }}.RPCClient()); err != nil {
					return errors.Wrap(err, "Transaction.Execute()")
				}

				return nil
			}); err != nil {
				return httpio.NewEncoder(w).ClientMessage(ctx, errors.Wrap(err, "spanner.Client.ReadWriteTransaction()"))
			}
		{{- else if .RPCMethod.IsDBRunner }}
		if err := p.Execute(ctx, {{ $.ReceiverName }}.ResourceClient(), {{ $.ReceiverName }}.RPCClient()); err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}
		{{- end }}

		return httpio.NewEncoder(w).Ok(nil)
	})
}
`

	rpcInterfacesTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"github.com/cccteam/ccc/resource"
)

type Method interface {
	Method() accesstypes.Resource
{{ FormatRPCInterfaceTypes .Types }}
}`

	computedResourceHandlerTemplate = `// Code generated by resourcegeneration. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"net/http"
	"time"

	{{ .LocalPackageImports }}
	cloudspanner "cloud.google.com/go/spanner"
	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource"
	"github.com/cccteam/httpio"
	"github.com/shopspring/decimal"
)

{{- if not .Resource.SuppressListHandler }}
func ({{ .ReceiverName }} *{{ .ApplicationName }}) {{ Pluralize .Resource.Name }}() http.HandlerFunc {
	type {{ GoCamel .Resource.Name }} struct {
		{{- range $field := .Resource.Fields }}
		{{ $field.Name }} {{ $field.Type}} ` + "`{{ $field.JSONTag }} {{ $field.PIITag }}`" + `
		{{- end }}
	}

	type response []map[string]any

	decoder := NewQueryDecoder[{{ .ComputedPackage }}.{{ .Resource.Name }}, {{ GoCamel .Resource.Name }}]({{ .ReceiverName }}, accesstypes.List)

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error {
		ctx, span := ccc.StartTrace(r.Context())
		defer span.End()

		querySet, err := decoder.Decode(r, {{ .ReceiverName }}.UserPermissions(r))
		if err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}

		resp := response{}
		for r, err := range {{ .ComputedPackage }}.List{{ .Resource.Name }}(ctx, querySet, {{ .ReceiverName }}.ResourceClient(), {{ .ReceiverName }}.ComputedClient()) {
			if err != nil {
				return httpio.NewEncoder(w).ClientMessage(ctx, err)
			}
			rec := (*{{ GoCamel .Resource.Name }})(r)
			rmap := make(map[string]any)
			for _, field := range querySet.Fields() {
				switch string(field) {
				{{- range .Resource.Fields }}
				case "{{ .Name }}":
					rmap["{{ Camel .Name }}"] = rec.{{ .Name }}
				{{- end }}
				}
			}
			resp = append(resp, rmap)
		}

		return httpio.NewEncoder(w).Ok(resp)
	})
}
{{- end }}

{{- if not .Resource.SuppressReadHandler }}
func ({{ .ReceiverName }} *{{ .ApplicationName }}) {{ .Resource.Name }}() http.HandlerFunc {
	type response struct {
		{{- range $field := .Resource.Fields }}
		{{ $field.Name }} {{ $field.Type}} ` + "`{{ $field.JSONTag }} {{ $field.PIITag }}`" + `
		{{- end }}
	}

	decoder := NewQueryDecoder[{{ .ComputedPackage }}.{{ .Resource.Name }}, response]({{ .ReceiverName }}, accesstypes.Read)

	return httpio.Log(func(w http.ResponseWriter, r *http.Request) error {
		ctx, span := ccc.StartTrace(r.Context())
		defer span.End()

		{{ if .Resource.HasCompoundPrimaryKey }}
		{{- range $_, $field := .Resource.PrimaryKeys }}
		{{ GoCamel $field.Name }} := httpio.Param[{{ $field.Type }}](r, router.{{ $.Resource.Name }}{{ $field.Name }})
		{{- end }}
		{{ else if $field := .Resource.PrimaryKey }}
		id := httpio.Param[{{ $field.Type }}](r, router.{{ .Resource.Name }}ID)
		{{ end }}

		querySet, err := decoder.Decode(r, {{ .ReceiverName }}.UserPermissions(r))
		if err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}

		{{ if .Resource.HasCompoundPrimaryKey }}
		row, err := {{ .ComputedPackage }}.Read{{ .Resource.Name }}(ctx, {{ range $i, $field := .Resource.PrimaryKeys }}{{ if $i }}, {{ end }}{{ GoCamel $field.Name }}{{ end }}, querySet, {{ .ReceiverName }}.ResourceClient(), {{ .ReceiverName }}.ComputedClient())
		{{ else if .Resource.PrimaryKey }}
		row, err := {{ .ComputedPackage }}.Read{{ .Resource.Name }}(ctx, id, querySet, {{ .ReceiverName }}.ResourceClient(), {{ .ReceiverName }}.ComputedClient()))
		{{ end }}
		if err != nil {
			return httpio.NewEncoder(w).ClientMessage(ctx, err)
		}
		rec := (*response)(row)
		rmap := make(map[string]any)
		for _, field := range querySet.Fields() {
			switch string(field) {
			{{- range .Resource.Fields }}
			case "{{ .Name }}":
				rmap["{{ Camel .Name }}"] = rec.{{ .Name }}
			{{- end }}
			}
		}

		return httpio.NewEncoder(w).Ok(rmap)
	})
}
{{- end }}
`
)

func fieldAccessors(patchType patchType) string {
	return fmt.Sprintf(`
		{{- range $field := .Resource.Fields }}
		{{ if eq false $field.IsPrimaryKey }}
		func (p *{{ $field.Parent.Name }}%[1]sPatch) Set{{ $field.Name }}(v {{ $field.ResolvedType }}) *{{ $field.Parent.Name }}%[1]sPatch {
			p.patchSet.Set("{{ $field.Name }}", v)

			return p
		}
		{{ end }}

		func (p *{{ $field.Parent.Name }}%[1]sPatch) {{ $field.Name }}() {{ $field.ResolvedType }} {
		{{ if $field.IsPrimaryKey -}} 
			v, _ := p.patchSet.Key("{{ $field.Name }}").({{ $field.ResolvedType }})
		{{ else -}} 
			v, _ := p.patchSet.Get("{{ $field.Name }}").({{ $field.ResolvedType }}) 
		{{ end }}

			return v
		}

		{{ if eq false $field.IsPrimaryKey  }}
		func (p *{{ $field.Parent.Name }}%[1]sPatch) {{ $field.Name }}IsSet() bool {
			return p.patchSet.IsSet("{{ $field.Name }}")
		}
		{{ end }}
		{{ end }}`, string(patchType))
}
