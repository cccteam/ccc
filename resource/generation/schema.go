package generation

import (
	"fmt"
	"path/filepath"
	"slices"
	"strings"

	"github.com/cccteam/ccc/resource/generation/parser"
	"github.com/cccteam/ccc/resource/generation/parser/commentlang"
	"github.com/go-playground/errors/v5"
)

func NewSchemaGenerator(resourceFilePath, schemaDestinationPath string) (Generator, error) {
	s := &schemaGenerator{
		resourceDestination: filepath.Dir(resourceFilePath),
		schemaDestination:   schemaDestinationPath,
		loadPackages:        []string{resourceFilePath},
	}

	return s, nil
}

func (s *schemaGenerator) Generate() error {
	packageMap, err := parser.LoadPackages(s.loadPackages...)
	if err != nil {
		return err
	}

	pStructs := parser.ParseStructs(packageMap["resources"])

	schemaInfo, err := newSchema(pStructs)
	if err != nil {
		return err
	}

	if err := s.generateSchemaMigrations(schemaInfo); err != nil {
		return err
	}

	if err := s.generateConversionMethods(); err != nil {
		return err
	}

	if err := s.generateMutations(); err != nil {
		return err
	}

	return nil
}

func (s *schemaGenerator) generateSchemaMigrations(schemaInfo *schema) error {
	if schemaInfo == nil {
		panic("schemaInfo cannot be nil")
	}

	// TODO:
	// - write to file
	return nil
}

func (s *schemaGenerator) generateConversionMethods() error {
	// TODO: determine which fields need to be transformed to fit new schema using astInfo in parser.Field
	return nil
}

func (s *schemaGenerator) generateMutations() error {
	// TODO: generate a spanner insert mutation for each table using the schema definition
	return nil
}

func (schemaGenerator) Close() {}

func newSchema(pStructs []*parser.Struct) (*schema, error) {
	s := &schema{
		tables: make([]*schemaTable, 0, len(pStructs)),
		views:  make([]*schemaView, 0, len(pStructs)),
	}

	for i := range pStructs {
		structComments, err := commentlang.ScanStruct(pStructs[i].Comments())
		if err != nil {
			return nil, errors.Wrapf(err, "%s commentlang.Scan()", pStructs[i].Error())
		}

		_, isView := structComments[commentlang.View]
		if isView {
			view, err := newSchemaView(pStructs[i])
			if err != nil {
				return nil, err
			}

			if err := view.resolveStructComments(structComments); err != nil {
				return nil, err
			}

			s.views = append(s.views, view)
		} else {
			table, err := newSchemaTable(pStructs[i])
			if err != nil {
				return nil, err
			}

			if err := table.resolveStructComments(structComments); err != nil {
				return nil, err
			}

			s.tables = append(s.tables, table)
		}
	}

	s.tables = slices.Clip(s.tables)
	s.views = slices.Clip(s.views)

	return s, nil
}

func newSchemaTable(pStruct *parser.Struct) (*schemaTable, error) {
	table := &schemaTable{
		Name:    pStruct.Name(),
		Columns: make([]*tableColumn, 0, pStruct.NumFields()),
	}

	for _, field := range pStruct.Fields() {
		col := tableColumn{
			Name:       field.Name(),
			IsNullable: isSQLTypeNullable(field),
			SQLType:    decodeSQLType(field),
		}

		fieldComments, err := commentlang.ScanField(field.Comments())
		if err != nil {
			return nil, errors.Wrap(err, "commentlang.ScanField()")
		}

		col, err = table.resolveFieldComment(col, fieldComments)
		if err != nil {
			return nil, err
		}

		table.Columns = append(table.Columns, &col)
	}

	return table, nil
}

func newSchemaView(pStruct *parser.Struct) (*schemaView, error) {
	view := &schemaView{
		Name:    pStruct.Name(),
		Columns: make([]*viewColumn, 0, pStruct.NumFields()),
	}

	for _, field := range pStruct.Fields() {
		col, err := newViewColumn(field)
		if err != nil {
			return nil, err
		}

		view.Columns = append(view.Columns, &col)
	}

	return view, nil
}

func isSQLTypeNullable(f *parser.Field) bool {
	if f.IsPointer() {
		return true
	}

	return strings.Contains(strings.ToLower(f.UnqualifiedTypeName()), "null")
}

func decodeSQLType(f *parser.Field) string {
	tt := f.Type()

	if f.TypeArgs() != "" {
		tt = f.TypeArgs()
	}

	switch tt {
	case "string":
		return "STRING(MAX)"
	case "bool":
		return "BOOL"
	case "UUID":
		return "STRING(36)"
	case "int":
		return "INT64"
	case "float":
		return "FLOAT64"
	default:
		panic(fmt.Sprintf("schemagen conversion unimplemented for type=%q", f.Type()))
	}
}

// TODO: move these elsewhere
const (
	migrationHeaderComment   = `-- GENERATED BY SCHEMA GEN. DO NOT EDIT.`
	tableMigrationUpTemplate = `{{ .MigrationHeaderComment }}
CREATE TABLE {{ .Resource.Name }} (
  {{- range $column := .Resource.Columns }}
  {{ $column.Name }} {{ $column.SQLType }} {{ if not $column.IsNullable }}NOT NULL{{ end }} {{ if $column.DefaultValue }}DEFAULT ({{ $column.DefaultValue }}){{ end }}{{ if $column.IsHidden }}HIDDEN{{ end }},
  {{- end }}

  {{ if .Resource.SearchTokens -}}
  SearchTokens TOKENLIST AS (
    TOKENLIST_CONCAT([
    {{- range $index, $searchToken := .Resource.SearchTokens }}
        {{ if $index }},{{ end }}({{ $searchToken.Name }}({{ $searchToken.Arg }}))
    {{- end }}
    ])
  ) HIDDEN,
  {{- end }}

  {{ range $constraint := .Resource.Constraints -}}
  CONSTRAINT {{ $constraint }},
  {{- end }}
) PRIMARY KEY ({{ .Resource.PrimaryKey }});

{{ range $index := .Resource.Indexes -}}
CREATE {{ $index.Type }} INDEX {{ $index.Name }} ON {{ .Resource.Name }}({{ $index.Argument }});
{{- end }}
`
	tableMigrationDownTemplate = `{{ .MigrationHeaderComment }}
{{ range $index := .Resource.Indexes -}}
DROP INDEX {{ $index.Name }};
{{- end }}
DROP TABLE {{ .Resource.Name }};
`

	viewMigrationUpTemplate = `{{ .MigrationHeaderComment }}
CREATE VIEW {{ .Resource.Name }}
SQL SECURITY INVOKER
AS 
SELECT
  {{- range $column := .Resource.Columns }}
  {{ $column.SourceTable }}.{{ $column.Name }},
  {{- end }}
{{ .Resource.Query }}
`
	viewMigrationDownTemplate = `{{ .MigrationHeaderComment }}
DROP VIEW {{ .View.Name }};
`
)
