package generation

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/cccteam/ccc/resource/generation/parser"
)

func NewSchemaGenerator(resourceFilePath, schemaDestinationPath string) (Generator, error) {
	s := &schemaGenerator{
		resourceDestination: filepath.Dir(resourceFilePath),
		schemaDestination:   schemaDestinationPath,
		loadPackages:        []string{resourceFilePath},
	}

	return s, nil
}

func (s *schemaGenerator) Generate() error {
	packageMap, err := parser.LoadPackages(s.loadPackages...)
	if err != nil {
		return err
	}

	pStructs, err := parser.ParseStructs(packageMap["resources"])
	if err != nil {
		return err
	}

	s.structs = pStructs

	if err := s.structsToSchema(); err != nil {
		return err
	}

	if err := s.generateSchemaMigrations(); err != nil {
		return err
	}

	if err := s.generateMutations(); err != nil {
		return err
	}

	return nil
}

func (s *schemaGenerator) structsToSchema() error {
	s.schemaResources = make(map[string]*schemaResource, len(s.structs))
	for i := range s.structs {
		res, err := structToSchemaResource(s.structs[i])
		if err != nil {
			return err
		}

		s.schemaResources[s.structs[i].Name()] = res
	}

	return nil
}

func (s *schemaGenerator) generateSchemaMigrations() error {
	// TODO:
	// - write to file
	return nil
}

func (s *schemaGenerator) generateMutations() error {
	return nil
}

func (schemaGenerator) Close() {}

func structToSchemaResource(pStruct *parser.Struct) (*schemaResource, error) {
	res := &schemaResource{
		Columns: make([]schemaColumn, 0, pStruct.NumFields()),
	}

	for _, f := range pStruct.Fields() {
		res.Columns = append(res.Columns, schemaColumn{
			Name:       f.Name(),
			SQLType:    sqlTypeFromField(f),
			IsNullable: isTypeNullable(f),
		})
	}

	if err := res.addStructComments(pStruct); err != nil {
		return nil, err
	}

	if err := res.addFieldComments(pStruct); err != nil {
		return nil, err
	}

	return res, nil
}

func isTypeNullable(f *parser.Field) bool {
	if f.IsPointer() {
		return true
	}

	return strings.Contains(strings.ToLower(f.UnqualifiedTypeName()), "null")
}

func sqlTypeFromField(f *parser.Field) string {
	switch f.UnqualifiedTypeName() {
	case "string":
		return "STRING(MAX)"
	case "bool", "IntToBool", "CharToBool":
		return "BOOL"
	case "IntToUUID":
		return "STRING(36)"
	case "int":
		return "INT64"
	default:
		// TODO: replace string type check with a function that is aware of the conversion packages generics
		// e.g. conversion.IntTo[ccc.UUID]
		panic(fmt.Sprintf("unknown fieldtype %q", f.UnqualifiedTypeName()))
	}
}

// TODO: move these elsewhere
const (
	migrationHeaderComment   = `-- GENERATED BY SCHEMA GEN. DO NOT EDIT.`
	tableMigrationUpTemplate = `{{ .MigrationHeaderComment }}
CREATE TABLE {{ .Resource.Name }} (
  {{- range $column := .Resource.Columns }}
  {{ $column.Name }} {{ $column.SQLType }} {{ if not $column.IsNullable }}NOT NULL{{ end }} {{ if $column.DefaultValue }}DEFAULT ({{ $column.DefaultValue }}){{ end }}{{ if $column.IsHidden }}HIDDEN{{ end }},
  {{- end }}

  {{ if .Resource.SearchTokens -}}
  SearchTokens TOKENLIST AS (
    TOKENLIST_CONCAT([
    {{- range $index, $searchToken := .Resource.SearchTokens }}
        {{ if $index }},{{ end }}({{ $searchToken.Name }}({{ $searchToken.Arg }}))
    {{- end }}
    ])
  ) HIDDEN,
  {{- end }}

  {{ range $constraint := .Resource.Constraints -}}
  CONSTRAINT {{ $constraint }},
  {{- end }}
) PRIMARY KEY ({{ .Resource.PrimaryKey }});

{{ range $index := .Resource.Indexes -}}
CREATE {{ $index.Type }} INDEX {{ $index.Name }} ON {{ .Resource.Name }}({{ $index.Argument }});
{{- end }}
`
	tableMigrationDownTemplate = `{{ .MigrationHeaderComment }}
{{ range $index := .Resource.Indexes -}}
DROP INDEX {{ $index.Name }};
{{- end }}
DROP TABLE {{ .Resource.Name }};
`

	viewMigrationUpTemplate = `{{ .MigrationHeaderComment }}
CREATE VIEW {{ .Resource.Name }}
SQL SECURITY INVOKER
AS 
SELECT
  {{- range $column := .Resource.Columns }}
  {{ $column.SourceTable }}.{{ $column.Name }},
  {{- end }}
{{ .Resource.Query }}
`
	viewMigrationDownTemplate = `{{ .MigrationHeaderComment }}
DROP VIEW {{ .View.Name }};
`
)
