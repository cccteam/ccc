package generation

import (
	"fmt"
	"iter"
	"path/filepath"
	"slices"
	"strings"

	"github.com/cccteam/ccc"
	"github.com/cccteam/ccc/accesstypes"
	"github.com/cccteam/ccc/resource/generation/parser"
	"github.com/cccteam/ccc/resource/generation/parser/genlang"

	"github.com/ettle/strcase"
)

const (
	booleanStr = "boolean"
)

// Generator provides methods for generating Go or Typescript for a resource-driven web application.
type Generator interface {
	Generate() error
	Close() error
}

const (
	genPrefix = "zz_gen"
)

// HandlerType describes the possible handlers implemented in a resource-driven API.
type HandlerType string

const (
	// AllHandlers is create, update, read, delete, and list handlers.
	AllHandlers HandlerType = "allHandlers"
	// ListHandler is the list handler.
	ListHandler HandlerType = "listHandler"
	// ReadHandler is the read handler.
	ReadHandler HandlerType = "readHandler"
	// PatchHandler is the patch handler.
	PatchHandler HandlerType = "patchHandler"
)

type packageDir string

func (p packageDir) Dir() string {
	if strings.HasSuffix(string(p), ".go") {
		s := strings.TrimSuffix(string(p), filepath.Base(string(p)))
		if s != "" {
			s = s[:len(s)-1]
		}

		return s
	}

	return string(p)
}

func (p packageDir) Package() string {
	if strings.HasSuffix(string(p), ".go") {
		return filepath.Base(filepath.Dir(string(p)))
	}

	return filepath.Base(string(p))
}

func handlerTypes() []HandlerType {
	return []HandlerType{
		AllHandlers,
		ListHandler,
		ReadHandler,
		PatchHandler,
	}
}

func (h HandlerType) template() string {
	switch h {
	case ReadHandler:
		return readTemplate
	case ListHandler:
		return listTemplate
	case PatchHandler:
		return patchTemplate
	default:
		panic(fmt.Sprintf("template(): unknown handler type: %s", h))
	}
}

// method returns the proper http method type for a HandlerType
func (h HandlerType) method() string {
	switch h {
	case ReadHandler, ListHandler:
		return "GET"
	case PatchHandler:
		return "PATCH"
	default:
		panic(fmt.Sprintf("Method(): unknown handler type: %s", h))
	}
}

type patchType string

const (
	createPatch patchType = "Create"
	updatePatch patchType = "Update"
)

type consolidateConfig struct {
	ConsolidatedResourceNames []string
	ConsolidateAll            bool
	ConsolidatedRoute         string
}

func (c consolidateConfig) IsConsolidated(resourceName string) bool {
	return !c.ConsolidateAll && slices.Contains(c.ConsolidatedResourceNames, resourceName) ||
		c.ConsolidateAll && !slices.Contains(c.ConsolidatedResourceNames, resourceName)
}

type generatedFileDeleteMethod int

const (
	// Used to remove files with the genPrefix value instead of reading the contents of the file.
	prefix generatedFileDeleteMethod = iota
	// Used to remove files that contain the header comment "// Code generated by resourcegeneration. DO NOT EDIT."
	headerComment
)

const (
	resourceInterfaceOutputName   = "resources_iface"
	resourceEnumsFileName         = "enums"
	routesOutputName              = "routes"
	routerTestOutputName          = "routes_test"
	consolidatedHandlerOutputName = "consolidated_handler"
)

type informationSchemaResult struct {
	TableName            string  `spanner:"TABLE_NAME"`
	ColumnName           string  `spanner:"COLUMN_NAME"`
	ConstraintName       *string `spanner:"CONSTRAINT_NAME"`
	IsPrimaryKey         bool    `spanner:"IS_PRIMARY_KEY"`
	IsForeignKey         bool    `spanner:"IS_FOREIGN_KEY"`
	ReferencedTable      *string `spanner:"REFERENCED_TABLE"`
	ReferencedColumn     *string `spanner:"REFERENCED_COLUMN"`
	SpannerType          string  `spanner:"SPANNER_TYPE"`
	IsNullable           bool    `spanner:"IS_NULLABLE"`
	IsIndex              bool    `spanner:"IS_INDEX"`
	IsUniqueIndex        bool    `spanner:"IS_UNIQUE_INDEX"`
	GenerationExpression *string `spanner:"GENERATION_EXPRESSION"`
	OrdinalPosition      int64   `spanner:"ORDINAL_POSITION"`
	KeyOrdinalPosition   int64   `spanner:"KEY_ORDINAL_POSITION"`
	HasDefault           bool    `spanner:"HAS_DEFAULT"`
}

type enumData struct {
	ID          string `spanner:"id"`
	Description string `spanner:"description"`
}

type tableMetadata struct {
	Columns map[string]columnMeta
	PkCount int
}

type columnMeta struct {
	IsPrimaryKey       bool
	IsForeignKey       bool
	IsNullable         bool
	IsIndex            bool
	IsUniqueIndex      bool
	OrdinalPosition    int64
	KeyOrdinalPosition int64
	ReferencedTable    string
	ReferencedColumn   string
	HasDefault         bool
}

type generatedRoute struct {
	Method        string
	Path          string
	HandlerFunc   string
	SharedHandler bool
	HandlerType   HandlerType
}

type rpcMethodInfo struct {
	*parser.Struct
	Fields []*rpcField
}

func (r *rpcMethodInfo) IsTxnRunner() bool {
	return r.Implements("TxnRunner")
}

func (r *rpcMethodInfo) IsDBRunner() bool {
	return r.Implements("DBRunner")
}

func (r *rpcMethodInfo) hasEnumeratedResource() bool {
	for _, field := range r.Fields {
		if field.IsEnumerated() {
			return true
		}
	}

	return false
}

func (r *rpcMethodInfo) HasLocalType() bool {
	for _, field := range r.Fields {
		if field.IsLocalType() {
			return true
		}
	}

	return false
}

type rpcField struct {
	*parser.Field
	typescriptType     string
	enumeratedResource *string
}

func (r rpcField) JSONTag() string {
	caser := strcase.NewCaser(false, nil, nil)
	camelCaseName := caser.ToCamel(r.Name())

	return fmt.Sprintf("json:%q", camelCaseName)
}

func (r *rpcField) TypescriptDataType() string {
	switch r.typescriptType {
	case "uuid":
		return stringGoType
	case "uuid[]":
		return stringGoType + "[]"
	case "civilDate":
		return "Date"
	case "civilDate[]":
		return "Date[]"
	default:
		return r.typescriptType
	}
}

func (r *rpcField) IsEnumerated() bool {
	return r.enumeratedResource != nil
}

func (r *rpcField) EnumeratedResource() string {
	if r.enumeratedResource == nil {
		return ""
	}

	return *r.enumeratedResource
}

func (r *rpcField) TypescriptDisplayType() string {
	if r.IsEnumerated() {
		return "enumerated"
	}

	return r.typescriptType
}

type computedResource struct {
	*parser.Struct
	Fields              []*computedField
	SuppressReadHandler bool
	SuppressListHandler bool
}

func (c *computedResource) HasCompoundPrimaryKey() bool {
	var count uint
	for _, field := range c.Fields {
		if field.IsPrimaryKey {
			count++
		}
	}

	return count > 0
}

func (c *computedResource) PrimaryKey() *computedField {
	for _, field := range c.Fields {
		if field.IsPrimaryKey {
			return field
		}
	}

	return nil
}

func (c *computedResource) PrimaryKeys() []*computedField {
	keys := make([]*computedField, 0)
	for _, field := range c.Fields {
		if field.IsPrimaryKey {
			keys = append(keys, field)
		}
	}

	return keys
}

type computedField struct {
	*parser.Field
	typescriptType     string
	IsPrimaryKey       bool
	KeyOrdinalPosition int
}

func (c *computedField) JSONTag() string {
	camelCaseName := caser.ToCamel(c.Name())

	return fmt.Sprintf("json:%q", camelCaseName)
}

func (c *computedField) IsPII() bool {
	tag, ok := c.LookupTag("conditions")
	if !ok {
		return false
	}

	conditions := strings.Split(tag, ",")

	return slices.Contains(conditions, "pii")
}

func (c *computedField) PIITag() string {
	if c.IsPII() {
		return `pii:"true"`
	}

	return ""
}

func (c *computedField) TypescriptDataType() string {
	if c.typescriptType == "uuid" {
		return stringGoType
	}
	if c.typescriptType == "civilDate" {
		return "Date"
	}

	return c.typescriptType
}

type resourceInfo struct {
	*parser.TypeInfo
	Fields             []*resourceField
	SuppressedHandlers []HandlerType
	IsVirtual          bool // Determines how CreatePatch is rendered in resource generation.
	IsConsolidated     bool
	PkCount            int
	DefaultsCreateType string
	DefaultsUpdateType string
	ValidateCreateType string
	ValidateUpdateType string
}

func (r *resourceInfo) HasNullBool() bool {
	for _, field := range r.Fields {
		if field.IsNullable && field.typescriptType == booleanStr {
			return true
		}
	}

	return false
}

func (r *resourceInfo) ListHandlerDisabled() bool {
	return slices.Contains(r.SuppressedHandlers, ListHandler)
}

func (r *resourceInfo) ReadHandlerDisabled() bool {
	return slices.Contains(r.SuppressedHandlers, ReadHandler)
}

func (r *resourceInfo) CreateHandlerDisabled() bool {
	return slices.Contains(r.SuppressedHandlers, PatchHandler)
}

func (r *resourceInfo) UpdateHandlerDisabled() bool {
	return slices.Contains(r.SuppressedHandlers, PatchHandler)
}

func (r *resourceInfo) DeleteHandlerDisabled() bool {
	return slices.Contains(r.SuppressedHandlers, PatchHandler)
}

// HasDefaultsCreateType indicates if a default create type has been registered
func (r *resourceInfo) HasDefaultsCreateType() bool {
	return r.DefaultsCreateType != ""
}

// HasDefaultsUpdateType indicates if a default update type has been registered
func (r *resourceInfo) HasDefaultsUpdateType() bool {
	return r.DefaultsUpdateType != ""
}

// HasValidateCreateType indicates if a validate create type has been registered
func (r *resourceInfo) HasValidateCreateType() bool {
	return r.ValidateCreateType != ""
}

// HasValidateUpdateType indicates if a validate update type has been registered
func (r *resourceInfo) HasValidateUpdateType() bool {
	return r.ValidateUpdateType != ""
}

func (r *resourceInfo) PrimaryKeys() iter.Seq2[int, *resourceField] {
	var i int

	return func(yield func(int, *resourceField) bool) {
		for _, f := range r.Fields {
			if !f.IsPrimaryKey {
				continue
			}

			if !yield(i, f) {
				return
			}

			i++
		}
	}
}

func (r *resourceInfo) HasCompoundPrimaryKey() bool {
	return r.PkCount > 1
}

func (r *resourceInfo) PrimaryKeyIsGeneratedUUID() bool {
	if r.PkCount > 1 {
		return false
	}

	for _, f := range r.Fields {
		if f.IsPrimaryKey {
			if f.IsForeignKey {
				return false
			}

			return f.Type() == "ccc.UUID"
		}
	}

	return false
}

func (r *resourceInfo) OperationPathPattern() string {
	if r.PkCount == 1 {
		return "/{id}"
	}

	var pattern string
	for i := range r.PkCount {
		pattern += fmt.Sprintf("/{id%d}", i+1)
	}

	return pattern
}

func (r *resourceInfo) PrimaryKeyType() string {
	for _, f := range r.Fields {
		if f.IsPrimaryKey {
			return f.Type()
		}
	}

	return ""
}

func (r *resourceInfo) PrimaryKey() *resourceField {
	for _, f := range r.Fields {
		if f.IsPrimaryKey {
			return f
		}
	}

	return nil
}

func (r *resourceInfo) IsQueryClauseEligible() bool {
	for _, field := range r.Fields {
		if field.IsQueryClauseEligible() {
			return true
		}
	}

	return false
}

type resourceField struct {
	*parser.Field
	Parent         *resourceInfo
	typescriptType string
	// Spanner stuff
	IsPrimaryKey       bool
	IsForeignKey       bool
	IsIndex            bool
	IsUniqueIndex      bool
	IsNullable         bool
	OrdinalPosition    int64 // Position of column in the table definition
	KeyOrdinalPosition int64 // Position of primary or foreign key in a compound key definition
	IsEnumerated       bool
	ReferencedResource string
	ReferencedField    string
	HasDefault         bool
}

// When generating QueryClauses for Null-style wrapper types we want to use the underlying type
// i.e. ccc.NullUUID -> ccc.UUID, spanner.NullString -> string
func (f *resourceField) UnwrappedNullType() *string {
	if !strings.HasPrefix(f.DerefUnqualifiedType(), "Null") {
		return nil
	}

	pStruct := f.AsStruct()
	if pStruct == nil {
		return nil
	}

	fields := pStruct.Fields()
	if len(fields) != 2 {
		return nil
	}

	var hasValidColumn bool
	for i := range fields {
		if fields[i].Name() == "Valid" && fields[i].DerefUnqualifiedType() == "bool" {
			hasValidColumn = true
		}
	}

	if !hasValidColumn {
		return nil
	}

	for i := range fields {
		if fields[i].Name() != "Valid" {
			return ccc.Ptr(fields[i].DerefResolvedType())
		}
	}

	return nil
}

func (f *resourceField) TypescriptDataType() string {
	if f.typescriptType == "uuid" {
		return stringGoType
	}
	if f.typescriptType == "civilDate" {
		return "Date"
	}
	if f.IsNullable && f.typescriptType == booleanStr {
		return "NullBoolean"
	}

	return f.typescriptType
}

func (f *resourceField) TypescriptDisplayType() string {
	if f.IsEnumerated {
		return "enumerated"
	}

	if f.IsNullable && f.typescriptType == booleanStr {
		return "nullboolean"
	}

	return f.typescriptType
}

func (f *resourceField) JSONTag() string {
	if f.IsInputOnly() {
		return fmt.Sprintf("json:%q", "-")
	}

	caser := strcase.NewCaser(false, nil, nil)
	camelCaseName := caser.ToCamel(f.Name())

	return fmt.Sprintf("json:%q", camelCaseName)
}

func (f *resourceField) JSONTagForPatch() string {
	if f.IsPrimaryKey || f.IsOutputOnly() {
		return fmt.Sprintf("json:%q", "-")
	}

	caser := strcase.NewCaser(false, nil, nil)
	camelCaseName := caser.ToCamel(f.Name())

	return fmt.Sprintf("json:%q", camelCaseName)
}

const indexTrue string = `index:"true"`

func (f *resourceField) IndexTag() string {
	if f.IsIndex {
		return indexTrue
	}

	if f.Parent.IsVirtual {
		t, ok := f.LookupTag("index")
		if ok && t == "true" {
			return indexTrue
		}
	}

	return ""
}

func (f *resourceField) PIITag() string {
	if f.IsPII() {
		return `pii:"true"`
	}

	return ""
}

func (f *resourceField) UniqueIndexTag() string {
	if f.IsUniqueIndex {
		return indexTrue
	}

	return ""
}

func (f *resourceField) AllowFilterTag() string {
	if f.HasTag("allow_filter") {
		return `allow_filter:"true"`
	}

	return ""
}

func (f *resourceField) IsPII() bool {
	tag, ok := f.LookupTag("conditions")
	if !ok {
		return false
	}

	conditions := strings.Split(tag, ",")

	return slices.Contains(conditions, "pii")
}

func (f *resourceField) IsImmutable() bool {
	tag, ok := f.LookupTag("conditions")
	if !ok {
		return false
	}

	conditions := strings.Split(tag, ",")

	return slices.Contains(conditions, "immutable")
}

func (f *resourceField) IsOutputOnly() bool {
	tag, ok := f.LookupTag("conditions")
	if !ok {
		return false
	}

	conditions := strings.Split(tag, ",")

	return slices.Contains(conditions, "output_only") || slices.Contains(conditions, "output_only_update_fn")
}

func (f *resourceField) IsInputOnly() bool {
	tag, ok := f.LookupTag("conditions")
	if !ok {
		return false
	}

	conditions := strings.Split(tag, ",")

	return slices.Contains(conditions, "input_only")
}

func (f *resourceField) DefaultCreateFuncName() string {
	tag, ok := f.LookupTag("default_create_fn")
	if !ok {
		return ""
	}

	return tag
}

func (f *resourceField) HasDefaultCreateFunc() bool {
	return f.DefaultCreateFuncName() != ""
}

func (f *resourceField) OutputOnlyUpdateFuncName() string {
	tag, ok := f.LookupTag("output_only_update_fn")
	if !ok {
		return ""
	}

	return tag
}

func (f *resourceField) HasOutputOnlyUpdateFunc() bool {
	return f.OutputOnlyUpdateFuncName() != ""
}

func (f *resourceField) ReadPermTag() string {
	tag, ok := f.LookupTag("perm")
	if !ok {
		return ""
	}

	permissions := strings.Split(tag, ",")

	if slices.Contains(permissions, string(accesstypes.Read)) {
		return fmt.Sprintf("perm:%q", accesstypes.Read)
	}

	return ""
}

func (f *resourceField) ListPermTag() string {
	tag, ok := f.LookupTag("perm")
	if !ok {
		return ""
	}

	permissions := strings.Split(tag, ",")

	if slices.Contains(permissions, string(accesstypes.List)) {
		return fmt.Sprintf("perm:%q", accesstypes.List)
	}

	return ""
}

func (f *resourceField) PatchPermTag() string {
	tag, ok := f.LookupTag("perm")
	if !ok {
		return ""
	}

	permissions := strings.Split(tag, ",")

	var patches []string
	for _, perm := range permissions {
		if perm != string(accesstypes.Read) && perm != string(accesstypes.List) {
			patches = append(patches, perm)
		}
	}

	if len(patches) != 0 {
		return fmt.Sprintf("perm:%q", strings.Join(patches, ","))
	}

	return ""
}

func (f *resourceField) ImmutableTag() string {
	if f.IsImmutable() {
		return `immutable:"true"`
	}

	return ""
}

func (f *resourceField) IsView() bool {
	return f.Parent.IsVirtual
}

func (f *resourceField) IsRequired() bool {
	if f.IsPrimaryKey && f.Parent.PkCount > 1 {
		return true
	}

	if f.IsPrimaryKey && f.Type() != "ccc.UUID" {
		return true
	}

	if !f.IsPrimaryKey && !f.IsNullable && !f.HasDefault && !f.HasDefaultCreateFunc() {
		return true
	}

	return false
}

func (f *resourceField) IsQueryClauseEligible() bool {
	if f.IsIndex || f.IsUniqueIndex {
		return true
	}

	return f.HasTag("allow_filter")
}

func generatedGoFileName(name string) string {
	return generatedFileName(name, "go")
}

func generatedTypescriptFileName(name string) string {
	return generatedFileName(name, "ts")
}

func generatedFileName(name, suffix string) string {
	return fmt.Sprintf("%s_%s.%s", genPrefix, name, suffix)
}

const (
	resourceKeyword           string = "resource"           // Designates a struct as a resource
	virtualKeyword            string = "virtual"            // Designates a struct as a virtual resource
	computedKeyword           string = "computed"           // Designates a struct as a computed resource
	rpcKeyword                string = "rpc"                // Designates a struct as an RPC method
	enumerateKeyword          string = "enumerate"          // Generate constants based on existing values in Spanner DB (from inserts in migrations directory)
	suppressKeyword           string = "suppress"           // Suppresses specified handler types from being generated
	defaultsCreateTypeKeyword string = "defaultsCreateType" // Specifies a type to call "Defaults()" on for setting defaults on resource creation
	defaultsUpdateTypeKeyword string = "defaultsUpdateType" // Specifies a type to call "Defaults()" on for setting defaults on resource update
	validateCreateTypeKeyword string = "validateCreateType" // Specifies a type to call "Validate()" on for validating a resource on creation
	validateUpdateTypeKeyword string = "validateUpdateType" // Specifies a type to call "Validate()" on for validating a resource on update
	primarykeyKeyword         string = "primarykey"         // Designates a field as a primary key in a Computed Resource
)

func resourceKeywords() map[string]genlang.KeywordOpts {
	return map[string]genlang.KeywordOpts{
		resourceKeyword:           {genlang.ScanStruct: genlang.NoArgs | genlang.Exclusive},
		virtualKeyword:            {genlang.ScanStruct: genlang.NoArgs | genlang.Exclusive},
		computedKeyword:           {genlang.ScanStruct: genlang.NoArgs | genlang.Exclusive},
		rpcKeyword:                {genlang.ScanStruct: genlang.NoArgs | genlang.Exclusive},
		enumerateKeyword:          {genlang.ScanNamedType: genlang.ArgsRequired | genlang.Exclusive},
		suppressKeyword:           {genlang.ScanStruct: genlang.ArgsRequired},
		defaultsCreateTypeKeyword: {genlang.ScanStruct: genlang.ArgsRequired | genlang.Exclusive},
		defaultsUpdateTypeKeyword: {genlang.ScanStruct: genlang.ArgsRequired | genlang.Exclusive},
		validateCreateTypeKeyword: {genlang.ScanStruct: genlang.ArgsRequired | genlang.Exclusive},
		validateUpdateTypeKeyword: {genlang.ScanStruct: genlang.ArgsRequired | genlang.Exclusive},
		primarykeyKeyword:         {genlang.ScanField: genlang.NoArgs},
	}
}
